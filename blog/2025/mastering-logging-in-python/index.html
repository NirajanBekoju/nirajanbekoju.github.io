<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd"> <html><body> <p>Logging in Python is a crucial aspect of software development, particularly for debugging, monitoring, and understanding the flow of your program. Python provides a built-in logging module that makes it easy to incorporate logging into your applications.</p> <h3>Why Logging Matters</h3> <p>Logging is essential in software development for several reasons:</p> <ol> <li> <strong>Debugging</strong>: Logs provide valuable information about what happened leading up to an error, helping developers diagnose and fix issues.</li> <li> <strong>Monitoring</strong>: Logs help monitor the health and performance of an application, allowing developers and system administrators to identify trends, spot anomalies, and take proactive measures.</li> <li> <strong>Auditing</strong>: Logs serve as a record of events within a system, important for compliance, security audits, and forensic investigations.</li> <li> <strong>Performance Analysis</strong>: Logs contain performance data like response times and resource usage, which can help optimize an application’s performance.</li> <li> <strong>Troubleshooting</strong>: Logs track events across distributed systems, making it easier to diagnose and resolve issues.</li> </ol> <h3>Levels of Logging</h3> <p>Python’s logging module supports different levels of logging, each serving a specific purpose:</p> <ol> <li> <strong>DEBUG</strong>: Detailed information, used for debugging. Typically too verbose for production.</li> <li> <strong>INFO</strong>: General information about normal program operation.</li> <li> <strong>WARNING</strong>: Indicates a potential issue that doesn’t prevent program execution but might need attention.</li> <li> <strong>ERROR</strong>: Signals a serious problem that the program can recover from but may require intervention.</li> <li> <strong>CRITICAL</strong>: Indicates a critical error that may cause the program to crash or stop functioning.</li> </ol> <h3>Practical Examples</h3> <h4>Basic Logger Configuration</h4> <p>Let’s start with a simple logger setup:</p> <pre>"""<br>logging module<br>"""<br><br>import logging<br><br>logger = logging.getLogger(__name__)<br><br>handler = logging.StreamHandler()<br><br>FMT = "%(levelname)s %(asctime)s [%(filename)s : %(funcName)s : %(lineno)d] %(message)s"<br>formatter = logging.Formatter(FMT)<br>handler.setFormatter(formatter)<br><br>logger.addHandler(handler)<br>logger.setLevel(logging.DEBUG)</pre> <p>Here, the stream handler sends logs to the console, and we define a custom format for log messages.</p> <p>We can now use this logger in another module:</p> <pre>"""<br>division function module<br>"""<br><br>from logger import logger<br><br>try:<br>    num1 = int(input("Enter first number: "))<br>    num2 = int(input("Enter second number: "))<br>    result = num1 / num2<br>    print(result)<br>except ZeroDivisionError as e:<br>    logger.error(e)</pre> <p>When a division by zero occurs, the output looks like this:</p> <pre>$ python3 division.py<br>Enter first number: 2<br>Enter second number: 0<br>ERROR 2024-04-16 10:13:48,341 [division.py : &lt;module&gt; : 13] division by zero</pre> <h4>Logger with File and Stream Handlers</h4> <p>We can extend our logger to write logs to both the console and a file:</p> <pre>"""<br>logger module with file and shell handler<br>"""<br><br>import logging<br><br>logger = logging.getLogger(__name__)<br><br>shell_handler = logging.StreamHandler()<br>file_handler = logging.FileHandler("debug.log")<br><br>logger.setLevel(logging.DEBUG)<br>shell_handler.setLevel(logging.WARNING)<br>file_handler.setLevel(logging.DEBUG)<br><br>FMT_SHELL = "%(levelname)s %(asctime)s %(message)s"<br>FMT_FILE = (<br>    "%(levelname)s %(asctime)s [%(filename)s:%(funcName)s:%(lineno)d] %(message)s"<br>)<br><br>shell_formatter = logging.Formatter(FMT_SHELL)<br>file_formatter = logging.Formatter(FMT_FILE)<br><br>shell_handler.setFormatter(shell_formatter)<br>file_handler.setFormatter(file_formatter)<br><br>logger.addHandler(shell_handler)<br>logger.addHandler(file_handler)logger = logging.getLogger(__name__)<br>shell_handler = logging.StreamHandler()<br>file_handler = logging.FileHandler("debug.log")</pre> <p>In this setup, the shell only shows warnings and above, while the file captures detailed debug information.</p> <h4>Rich Logger for Better Readability</h4> <p>Using the rich library, we can make our logs more readable:</p> <pre>"""<br>rich logger module<br>"""<br><br>import logging<br><br>from rich.logging import RichHandler<br><br>logger = logging.getLogger(__name__)<br><br># the handler determines where the logs go: stdout/file<br>shell_handler = RichHandler()<br>file_handler = logging.FileHandler("debug.log")<br><br>logger.setLevel(logging.DEBUG)<br>shell_handler.setLevel(logging.DEBUG)<br>file_handler.setLevel(logging.DEBUG)<br><br># the formatter determines what our logs will look like<br>FMT_SHELL = "%(message)s"<br>FMT_FILE = (<br>    "%(levelname)s %(asctime)s [%(filename)s:%(funcName)s:%(lineno)d] %(message)s"<br>)<br><br>shell_formatter = logging.Formatter(FMT_SHELL)<br>file_formatter = logging.Formatter(FMT_FILE)<br><br>shell_handler.setFormatter(shell_formatter)<br>file_handler.setFormatter(file_formatter)<br><br>logger.addHandler(shell_handler)</pre> <p>The rich library enhances console output with better formatting and color.</p> <h3>Conclusion</h3> <p>Python’s logging module is a powerful tool that helps developers track, debug, and monitor applications efficiently. Whether you’re using basic logging or integrating advanced features like the rich library, well-structured logs can save time and effort when diagnosing issues and analyzing performance.</p> <p>Happy logging!</p> <p><img src="https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=9c2b55db03e4" width="1" height="1" alt=""></p> </body></html>