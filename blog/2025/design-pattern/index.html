<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd"> <html><body> <p>Design pattern is a general repeatable solution to a commonly occurring problem in software design. A design pattern isn’t a finished design that can be transformed directly into code. It is a description or template for how to solve a problem that can be used in many different situations.</p> <h3>Why learn design patterns?</h3> <ul> <li>Design pattern are a toolkit of tried and tested solutions to common problems in software design.</li> <li>Design patterns define a common language that you and your teammates can use to communicate more efficiently.</li> </ul> <h3>Criticism of design patterns</h3> <ul> <li>“If all you have is a hammer, everything looks like a nail”. This is the the problem that haunts many beginners who have just familiarized themselves with design patterns. Having learned about patterns, they try to apply them everywhere, even in situations where simple code would do just fine.</li> <li>Most design patterns lacks formal foundations.</li> </ul> <h3>Classification of patterns</h3> <h3>Creational Patterns</h3> <p>Creational patterns are design patterns that deal with object creation mechanisms, trying to create objects in a manner suitable to the situation. The basic form of object creation could result in design problems or added complexity to the design. Creational design patterns solve this problem by somehow controlling this object creation.</p> <ul> <li> <strong>Singleton:</strong> A class of which only a single instance can exists.</li> <li> <strong>Abstract Factory:</strong> Create an instance of several families of classes</li> <li> <strong>Builder:</strong> Separates object construction from its representation.</li> <li> <strong>Factory Method:</strong> Creates an instance of several derived classes.</li> <li> <strong>Prototype:</strong> A fully initialized instance to be copied or cloned.</li> </ul> <h3>Structural Patterns</h3> <p>These patterns explain how to assemble objects and classes into large structures while keeping these structures flexible and efficient.</p> <ul> <li> <strong>Adapter:</strong> Adapter is a structural design pattern that allows objects with incompatible interfaces to collaborate.</li> <li> <strong>Bridge:</strong> Bridge lets you split a large class or a set of closely related classes into two separate hierarchies: abstraction and implementation, which can be developed independently of each other.</li> <li> <strong>Composite:</strong> Composite lets you compose objects into tree structures and then work with these structures as if they were individual objects.</li> <li> <strong>Decorator:</strong> Decorator lets you attach new behaviors to objects by placing these objects inside special wrapper objects that contain the behaviors.</li> <li> <strong>Facade:</strong> Facade is a structural design that provides a simplified interface to a library, a framework, or any other complex set of classes.</li> </ul> <h3>Behavioral Patterns</h3> <p>These patterns are concerned with algorithms and the assignment of responsibilities between objects.</p> <ul> <li> <strong>Chain of Responsibility:</strong> Chain of Responsibility is a behavioral design pattern that lets you pass requests along a chain of handlers.</li> <li> <strong>Iterator:</strong> Iterator let you traverse elements of a collection without exposing its underlying representation (list, stack, tree, etc.)</li> <li> <strong>Memento:</strong> Memento lets you save and restore the previous state of an object without revealing the detail of its implementation.</li> </ul> <p><img src="https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=49267e419a5b" width="1" height="1" alt=""></p> </body></html>