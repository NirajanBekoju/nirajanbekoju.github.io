<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd"> <html><body> <p>SOLID is groups of 5 principles that is used to build a better object-oriented code. These principles are:</p> <ol> <li>Single Responsibility principle</li> <li>Open-Closed principle</li> <li>Liskov substitution principle</li> <li>Interface segregation principle</li> <li>Dependency inversion principle</li> </ol> <h3>1. Single Responsibility Principle</h3> <p>It states that a class should have only one responsibility. If a class has more than one responsibilities, it should be divided into separate class.</p> <p><strong>Example:</strong></p> <p>Say, we want to implement a simple program to interact with the library catalog system. For that, let’s create a python class Book to represent a single book with attributes: title, author, genre, availability(whether the book is available for borrowing or not).</p> <pre>class Book:<br>    def __init__(self, title, author, isbn, genre, availability):<br>        self.title = title<br>        self.author = author<br>        self.isbn = isbn <br>        self.genre = genre <br>        self.availability = availability<br>    <br>    def get_detail(self):<br>        return (self.title, self.author, self.isbn, self.genre, self.availability)</pre> <p>Now, that we created a class for book, let’s create a LibraryCatalog class to manage the collection of books with following functionalities:</p> <ol> <li>add books by storing each book objects.</li> <li>get book details and get all books from the list of objects</li> </ol> <pre>class LibraryCatalog:<br>    def __init__(self):<br>        self.books_list = []<br>    <br>    def add_book(self, book):<br>        self.books_list.append(book)<br>    <br>    def get_book_details(self, title):<br>        for book in self.books_list:<br>            if book.title == title:<br>                return book.get_detail()<br>        return "Book not found in library catalog"<br>    <br>    def get_all_books(self):<br>        if len(self.books_list) == 0:<br>            return "No books available in the catalog"<br>        return [book.get_detail() for book in self.books_list]</pre> <p>Now, we need a book borrowing process, let’s implement this resposibility with BookMangaer Class. Here, we have to check the availability of the book before borrowing them and make them available to borrow after returning them.</p> <pre>class BookManager:<br>    """<br>    class for borrowing and returning book<br>    """<br>    def __init__(self, library_catalog:LibraryCatalog):<br>        self.books_list = library_catalog.books_list<br>    <br>    def borrow_book(self, title):<br>        for book in self.books_list:<br>            if book.title == title:<br>                if book.availability:<br>                    book.availability = False <br>                    print(f"{title} is borrowed.")<br>                else:<br>                    print(f"{title} is not available")<br><br>        print("f{title} is not found in library catalog")<br><br>    def return_book(self, title):<br>        for book in self.books_list:<br>            if book.title == title:<br>                if not book.availability:<br>                    book.availability = True <br>                    print(f"{title} is returned.")<br>                else:<br>                    print(f"{title} is already available")<br><br>        print("f{title} is not found in library catalog")</pre> <p>We have divided the responsibility of borrowing/returning, add/get book details and book details into different class. It follows the single responsibility principle.The overall implementation is as follow:</p> <pre>class Book:<br>    def __init__(self, title, author, isbn, genre, availability):<br>        self.title = title<br>        self.author = author<br>        self.isbn = isbn <br>        self.genre = genre <br>        self.availability = availability<br>    <br>    def get_detail(self):<br>        return (self.title, self.author, self.isbn, self.genre, self.availability)<br><br>class LibraryCatalog:<br>    def __init__(self):<br>        self.books_list = []<br>    <br>    def add_book(self, book):<br>        self.books_list.append(book)<br>    <br>    def get_book_details(self, title):<br>        for book in self.books_list:<br>            if book.title == title:<br>                return book.get_detail()<br>        return "Book not found in library catalog"<br>    <br>    def get_all_books(self):<br>        if len(self.books_list) == 0:<br>            return "No books available in the catalog"<br>        return [book.get_detail() for book in self.books_list]<br><br>class BookManager:<br>    """<br>    class for borrowing and returning book<br>    """<br>    def __init__(self, library_catalog:LibraryCatalog):<br>        self.books_list = library_catalog.books_list<br>    <br>    def borrow_book(self, title):<br>        for book in self.books_list:<br>            if book.title == title:<br>                if book.availability:<br>                    book.availability = False <br>                    print(f"{title} is borrowed.")<br>                else:<br>                    print(f"{title} is not available")<br><br>        print("f{title} is not found in library catalog")<br><br>    def return_book(self, title):<br>        for book in self.books_list:<br>            if book.title == title:<br>                if not book.availability:<br>                    book.availability = True <br>                    print(f"{title} is returned.")<br>                else:<br>                    print(f"{title} is already available")<br><br>        print("f{title} is not found in library catalog")<br><br><br>catalog = LibraryCatalog()<br>book_manager = BookManager(catalog)<br><br>book1 = Book("Harry Potter and the Philosopher's Stone", "J.K. Rowling", "9780747532743", "Fantasy", True)<br>book2 = Book("The Great Gatsby", "F. Scott Fitzgerald", "9780743273565", "Classic", True)<br>catalog.add_book(book1)<br>catalog.add_book(book2)<br><br>print()<br>print("get all books")<br>print(catalog.get_all_books())<br><br>print()<br>print("get individual book detail")<br>book_title = "The Great Gatsby"<br>print(catalog.get_book_details(title=book_title))<br><br>print()<br>print("BORROW BOOK")<br>book_manager.borrow_book(book_title)<br>print(catalog.get_book_details(title=book_title))<br><br>print("\n")<br>print("RETURN BOOK")<br>book_manager.return_book(book_title)<br>print(catalog.get_book_details(title=book_title))</pre> <h3>2. Open Closed principle</h3> <p>Open closed principles states that software entities(classes, modules, functions, etc.) should be open for extension, but closed for modification.</p> <p>Here, Product class is implemented and total price is calculated based on the price of the product.</p> <pre>class Product:<br>    def __init__(self, price):<br>        self.price = price<br><br>def calculate_total_price(products):<br>    total_price = 0<br>    for product in products:<br>        total_price += product.price<br>    return total_price<br><br># Using the calculate_total_price function with a list of products<br>products = [Product(100), Product(50), Product(75)]<br>print("Total Price:", calculate_total_price(products))</pre> <p>Let’s say, we have to add a discount features, where some products might have a discount applied to their prices. To add this feature, we would need to modify the Product class and calculate_total_price function. This violates the open closed principle. So to incorporate the discount features, we can create a new class Discount that can provide the discount for the products as shown below.</p> <pre>class Product:<br>    def __init__(self, price):<br>        self.price = price<br><br><br>def calculate_total_price(products):<br>    total_price = 0<br>    for product in products:<br>        total_price += product.price<br>    return total_price<br><br><br>class Discount:<br>    def __init__(self, product: Product, discount_percent: float):<br>        """<br>        discount_percent(float) = [0,..., 1]<br>        """<br>        self.product = product<br>        self.discount_percent = discount_percent<br><br>    def give_discount(self):<br>        self.product.price = self.product.price * (1 - self.discount_percent)<br><br><br># Using the calculate_total_price function with a list of products<br>products = [Product(200), Product(100), Product(50)]<br>print("Total Price before discount:", calculate_total_price(products))<br><br># apply discount<br>discount_percent = 0.2<br>for product in products:<br>    Discount(product, discount_percent).give_discount()<br><br>print("Total Price after discount:", calculate_total_price(products))</pre> <h3>3. Liskov Substitution Principle(LSP)</h3> <p>It states that Sub types must be substitutable for their base types. It means objects should be replaceable by their subtypes without altering how the program works.</p> <p><strong>Example:</strong> Below is an implementation of a banking system for account handling. There is a savings account and a checking account class. The cheking account inherits the savings account as both have the same functionality and the checking account allows overdrafts (allow processing transactions even if there is not sufficient balance). Now, we are going to redisgn the following program such that it follows the Liskov Substitution Principle.</p> <pre>class SavingsAccount():<br>    def __init__(self, balance) -&gt; None:<br>        self.balance = balance<br><br>    def withdraw(self, amount):<br>        # Savings account does not allow overdrafts<br>        if amount &lt;= self.balance:<br>            self.balance -= amount<br>            print(f"Withdrew ${amount}. Remaining balance: ${self.balance}")<br><br>        else:<br>            print("Insufficient funds!")<br><br>class CheckingAccount(SavingsAccount):<br>    def __init__(self, balance, overdraft_limit):<br>        super().__init__(balance)<br>        self.overdraft_limit = overdraft_limit<br><br>    def withdraw(self, amount):<br>        # Checking account allows overdrafts but with a limit<br>        if amount &lt;= self.balance + self.overdraft_limit:<br>            self.balance -= amount<br>            print(f"Withdrew ${amount}. Remaining balance: ${self.balance}")<br>        else:<br>            print("Exceeds overdraft limit or insufficient funds!")<br><br>def perform_bank_actions(account):<br>    account.withdraw(100)<br>    account.withdraw(200)<br>    account.withdraw(500)<br><br>if __name__ == "__main__":<br>    # Creating instances of SavingsAccount and CheckingAccount<br>    savings_account = SavingsAccount(500)<br>    checking_account = CheckingAccount(1000, overdraft_limit=200)<br><br>    # Performing actions on both accounts<br>    perform_bank_actions(savings_account)<br>    perform_bank_actions(checking_account)</pre> <p>In this example, we can’t substitute the instance of savings account to the checking account. Even though, a checking account is a specific type of a saving account, the classes that represent those account shouldn’t be in a parent-child relationship if LSP is followed.</p> <p>To follow LSP, we can create a base class for both savings account and checking account as follow:</p> <pre>from abc import ABC, abstractmethod<br><br>class Account(ABC):<br>    @abstractmethod<br>    def withdraw(self):<br>        pass<br><br>class SavingsAccount(Account):<br>    def __init__(self, balance) -&gt; None:<br>        self.balance = balance<br><br>    def withdraw(self, amount):<br>        # Savings account does not allow overdrafts<br>        if amount &lt;= self.balance:<br>            self.balance -= amount<br>            print(f"Withdrew ${amount}. Remaining balance: ${self.balance}")<br><br>        else:<br>            print("Insufficient funds!")<br><br><br>class CheckingAccount(Account):<br>    def __init__(self, balance, overdraft_limit):<br>        self.balance = balance<br>        self.overdraft_limit = overdraft_limit<br><br>    def withdraw(self, amount):<br>        # Checking account allows overdrafts but with a limit<br>        if amount &lt;= self.balance + self.overdraft_limit:<br>            self.balance -= amount<br>            print(f"Withdrew ${amount}. Remaining balance: ${self.balance}")<br>        else:<br>            print("Exceeds overdraft limit or insufficient funds!")<br><br><br>def perform_bank_actions(account):<br>    account.withdraw(100)<br>    account.withdraw(200)<br>    account.withdraw(500)<br><br><br>if __name__ == "__main__":<br>    # Creating instances of SavingsAccount and CheckingAccount<br>    savings_account = SavingsAccount(500)<br>    checking_account = CheckingAccount(1000, overdraft_limit=200)<br><br>    # Performing actions on both accounts<br>    perform_bank_actions(savings_account)<br>    perform_bank_actions(checking_account)</pre> <h3>4. Interface Segregation Principle(ISP)</h3> <p>The main idea regarding ISP is Clients should not be forced to depend upon methods that they donot use. Interfaces belongs to clients, not to hierarchies.</p> <p><strong>Example:</strong></p> <p>Suppose we have an interface called PaymentProcessor that defines methods for processing payments and refunds. Then, we have a class called OnlinePaymentProcessor that implements the PaymentProcessor interface. However, some parts of our system only need to process payments and don’t need to handle refunds.</p> <pre>from abc import ABC, abstractmethod<br><br>class PaymentProcessor(ABC):<br>    @abstractmethod<br>    def process_payment(self, amount):<br>        pass<br><br>    @abstractmethod<br>    def process_refund(self, amount):<br>        pass<br><br>class OnlinePaymentProcessor(PaymentProcessor):<br>    def process_payment(self, amount):<br>        print(f"Processing payment of ${amount}")<br><br>    def process_refund(self, amount):<br>        print(f"Processing refund of ${amount}")</pre> <p>Now, we need to redesign this program such that it follows the ISP principle.</p> <pre>from abc import ABC, abstractmethod<br><br><br>class ProcessPayment(ABC):<br>    @abstractmethod<br>    def process_payment(self):<br>        pass<br><br><br>class ProcessFund(ABC):<br>    @abstractmethod<br>    def process_refund(self):<br>        pass<br><br><br>class ProcessPayOnly(ProcessPayment):<br>    def process_payment(self, amount):<br>        print(f"Processing payment of ${amount}")<br><br><br>class ProcessFundOnly(ProcessFund):<br>    def process_refund(self, amount):<br>        print(f"Processing refund of ${amount}")<br><br><br>class ProcessPayFundBoth(ProcessPayment, ProcessFund):<br>    def process_payment(self, amount):<br>        print(f"Processing payment of ${amount}")<br><br>    def process_refund(self, amount):<br>        print(f"Processing refund of ${amount}")</pre> <p>Here, we created two separate class for payment and fund process and inherit them as required for different part of the system and so client is not forced to depend on methods they don’t use as per this implementation. Hence, ISP is followed.</p> <h3>5. Dependency Inversion Principle(DIP)</h3> <p>It states, “Abstractions should not depend upon details. Details should depend upon abstractions.”</p> <p><strong>Example:</strong> Suppose, we have a NotificationService class that is responsible for sending notifiction. The NotificationService class directly depends on the EmailSender Class to send emails. Hence, it violates the Dependency Inversion Principle. The high level NotificationService should not depend on the low-level EmailSender class, as it tightly couples the classes together.</p> <pre>class EmailSender:<br>    def send_email(self, recipient, subject, message):<br>        # Code to send an email<br>        print(f"Sending email to {recipient}: {subject} - {message}")<br><br>class NotificationService:<br>    def __init__(self):<br>        self.email_sender = EmailSender()<br><br>    def send_notification(self, recipient, message):<br>        self.email_sender.send_email(recipient, "Notification", message)<br><br># Using the NotificationService to send a notification<br>notification_service = NotificationService()<br>notification_service.send_notification("user@example.com", "Hello, this is a notification!")</pre> <p>Suppose, we have to incorporate the SMSSender too in the above implementation. Then, due to tight dependency between the NotificationService and the EmailSender, it becomes a necessity to change the implemenation of NotificationService. So, it is not very scalable. Hence, we need to apply dependency inversion principle such that we can add different kinds of Notification Sender like EmailSender, SMSSender, etc. as done in the following implementation.</p> <pre>from abc import ABC, abstractmethod<br><br><br>class MessageSender(ABC):<br>    @abstractmethod<br>    def send_message(self, recipient, message):<br>        pass<br><br><br>class EmailSender(MessageSender):<br>    def send_message(self, recipient, message):<br>        print(f"Sending email to {recipient}: {message}")<br><br><br>class SMSSender(MessageSender):<br>    def send_message(self, recipient, message):<br>        print(f"Sending SMS to {recipient}: {message}")<br><br><br>class NotificationService:<br>    def __init__(self, sender: MessageSender) -&gt; None:<br>        self.sender = sender<br><br>    def send_notification(self, recipient, message):<br>        self.sender.send_message(recipient, message)<br><br><br>email_sender = EmailSender()<br>notification_service = NotificationService(email_sender)<br>notification_service.send_notification(<br>    "abcd@fusemachines.com", "this is a notification"<br>)<br><br>sms_sender = SMSSender()<br>notification_service = NotificationService(sms_sender)<br>notification_service.send_notification("9843123122", "this is a notification")class MessageSender(ABC):<br>    @abstractmethod<br>    def send_message(self, recipient, message):<br>        pass</pre> <h3>Conclusion</h3> <p>The SOLID principles are fundamental guidelines for writing clean, maintainable, and scalable object-oriented code. By following these principles — Single Responsibility, Open-Closed, Liskov Substitution, Interface Segregation, and Dependency Inversion — developers can avoid code smells, reduce tight coupling, and make their systems more adaptable to change. Understanding and applying SOLID principles ensures that your code remains robust and easy to extend as requirements evolve. Thank you for reading!</p> <p><img src="https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=421921b3992b" width="1" height="1" alt=""></p> </body></html>