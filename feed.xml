<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator><link href="https://nirajanbekoju.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://nirajanbekoju.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2025-03-06T02:19:13+00:00</updated><id>https://nirajanbekoju.github.io/feed.xml</id><title type="html">blank</title><subtitle>A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. </subtitle><entry><title type="html">Improving Code Quality in Python with Pylint</title><link href="https://nirajanbekoju.github.io/blog/2025/improving-code-quality-in-python-with-pylint/" rel="alternate" type="text/html" title="Improving Code Quality in Python with Pylint"/><published>2025-03-06T01:44:49+00:00</published><updated>2025-03-06T01:44:49+00:00</updated><id>https://nirajanbekoju.github.io/blog/2025/improving-code-quality-in-python-with-pylint</id><content type="html" xml:base="https://nirajanbekoju.github.io/blog/2025/improving-code-quality-in-python-with-pylint/"><![CDATA[<p>Writing clean, efficient, and error-free code is crucial for any Python developer. One of the best tools for maintaining high code quality is <strong>Pylint</strong> — a powerful static code analyzer for Python. Let’s dive into how Pylint works, the types of errors it catches, and how we can improve our code using it.</p> <h3>What is Pylint?</h3> <p>Pylint is a static code analysis tool for Python 2 and 3, with its latest version supporting Python 3.8.0 and above. It analyzes your code <strong>without running it</strong> and checks for:</p> <ul><li><strong>Errors</strong> in the code</li><li><strong>Coding standard violations</strong></li><li><strong>Code smells</strong> (areas that need refactoring)</li><li><strong>Suggestions</strong> for better code structure</li></ul> <p>Pylint also gives your code a <strong>score out of 10</strong> based on the number and severity of issues present.</p> <h3>Types of Errors in Pylint</h3> <p>Pylint categorizes issues into five distinct types:</p> <ul><li><strong>C: Convention</strong> — Violations of coding style and best practices</li><li><strong>R: Refactor</strong> — Code that could be simplified or restructured for clarity</li><li><strong>W: Warning</strong> — Potential issues that might not stop execution but are problematic</li><li><strong>E: Error</strong> — Clear programming mistakes</li><li><strong>F: Fatal</strong> — Serious errors that prevent Pylint from running</li></ul> <p>Let’s see Pylint in action with some examples.</p> <h3>Example</h3> <pre># Write a Python program that takes two integers as input and performs division (num1 / num2). Handle the ZeroDivisionError and display a custom error message when the second number is zero.<br />import logging<br /><br />logging.basicConfig(<br />    filename=&quot;exception_handling.log&quot;, encoding=&quot;utf-8&quot;, level=logging.DEBUG<br />)<br /><br />try:<br />    num1 = int(input(&quot;Enter first number: &quot;))<br />    num2 = int(input(&quot;Enter second number: &quot;))<br />    result = num1 / num2<br />    print(result)<br />except ZeroDivisionError as e:<br />    logging.error(e)<br /><br /># Write a Python program that takes user input for age. Create a custom exception InvalidAgeError to handle cases where the age is below 0 or above 120.<br />class InvalidAgeError(Exception):<br />    pass<br /><br /><br />try:<br />    age = int(input(&quot;Enter your age: &quot;))<br />    if age &lt; 0 or age &gt; 120:<br />        raise InvalidAgeError(&quot;Age must be between 0 and 120&quot;)<br />    print(age)<br />except InvalidAgeError as e:<br />    logging.error(f&quot;{e}&quot;)Example 2: Custom Exception for Age Validation</pre> <h3>Pylint Analysis and Results</h3> <p>When we examine above code using the pylint, we get different errors as given below. Our current score is 6.67.$ pylint 1_exception_handling.py</p> <p>We get several errors and warnings:</p> <pre>$ pylint 1_exception_handling.py <br />************* Module 1_exception_handling<br />1_exception_handling.py:1:0: C0301: Line too long (190/100) (line-too-long)<br />1_exception_handling.py:16:0: C0301: Line too long (152/100) (line-too-long)<br />1_exception_handling.py:1:0: C0114: Missing module docstring (missing-module-docstring)<br />1_exception_handling.py:1:0: C0103: Module name &quot;1_exception_handling&quot; doesn&#39;t conform to snake_case naming style (invalid-name)<br />1_exception_handling.py:17:0: C0115: Missing class docstring (missing-class-docstring)<br />1_exception_handling.py:27:4: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)<br /><br />------------------------------------------------------------------<br />Your code has been rated at 6.67/10 (previous run: 7.22/10, -0.56)Our initial Pylint score is 6.67/10.</pre> <h3>Fixing the Errors</h3> <p>Let’s fix these issues step by step:</p> <ul><li><strong>line-too-long</strong>: Break long lines into multiple lines</li><li><strong>missing-module-docstring</strong>: Add a docstring at the top of the module</li><li><strong>invalid-name</strong>: Rename the module to follow snake_case convention</li><li><strong>missing-class-docstring</strong>: Add a docstring to the InvalidAgeError class</li><li><strong>logging-fstring-interpolation</strong>: Use %s formatting instead of f-strings in logging</li></ul> <p>Here’s the <strong>refactored code</strong>:</p> <pre>&quot;&quot;&quot;<br />Exception Handling Assignments<br />&quot;&quot;&quot;<br /><br /># Write a Python program that takes two integers as input and performs division (num1 / num2).<br /># Handle the ZeroDivisionError and display a custom error message when the second number is zero.<br /><br />import logging<br /><br />logging.basicConfig(<br />    filename=&quot;exception_handling.log&quot;, encoding=&quot;utf-8&quot;, level=logging.DEBUG<br />)<br /><br />try:<br />    num1 = int(input(&quot;Enter first number: &quot;))<br />    num2 = int(input(&quot;Enter second number: &quot;))<br />    result = num1 / num2<br />    print(result)<br />except ZeroDivisionError as e:<br />    logging.error(&quot;%s&quot;, e)<br /><br /><br /># Write a Python program that takes user input for age.<br /># Create a custom exception InvalidAgeError to handle cases where the age is below 0 or above 120.<br />class InvalidAgeError(Exception):<br />    &quot;&quot;&quot;custom exception class for invalid age input&quot;&quot;&quot;<br /><br /><br />try:<br />    age = int(input(&quot;Enter your age: &quot;))<br />    if age &lt; 0 or age &gt; 120:<br />        raise InvalidAgeError(&quot;Age must be between 0 and 120&quot;)<br />    print(age)<br />except InvalidAgeError as e:<br />    logging.error(&quot;%s&quot;, e)import logging</pre> <h3>Final Pylint Score</h3> <p>Running Pylint again:</p> <pre>$ pylint exception_handling.py <br /><br />--------------------------------------------------------------------<br />Your code has been rated at 10.00/10 (previous run: 10.00/10, +0.00)</pre> <p>🎉 <strong>Perfect score!</strong></p> <h3>Conclusion</h3> <p>Using Pylint regularly helps maintain clean, readable, and efficient Python code. It enforces best practices, catches errors early, and suggests improvements — making you a better developer in the long run. Start integrating Pylint into your workflow and aim for that perfect <strong>10/10</strong>!</p> <p><img src="https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=9f598d873e94" width="1" height="1" alt=""/></p>]]></content><author><name></name></author></entry><entry><title type="html">Design Pattern</title><link href="https://nirajanbekoju.github.io/blog/2025/design-pattern/" rel="alternate" type="text/html" title="Design Pattern"/><published>2025-03-06T01:31:49+00:00</published><updated>2025-03-06T01:31:49+00:00</updated><id>https://nirajanbekoju.github.io/blog/2025/design-pattern</id><content type="html" xml:base="https://nirajanbekoju.github.io/blog/2025/design-pattern/"><![CDATA[<p>Design pattern is a general repeatable solution to a commonly occurring problem in software design. A design pattern isn’t a finished design that can be transformed directly into code. It is a description or template for how to solve a problem that can be used in many different situations.</p> <h3>Why learn design patterns?</h3> <ul><li>Design pattern are a toolkit of tried and tested solutions to common problems in software design.</li><li>Design patterns define a common language that you and your teammates can use to communicate more efficiently.</li></ul> <h3>Criticism of design patterns</h3> <ul><li>“If all you have is a hammer, everything looks like a nail”. This is the the problem that haunts many beginners who have just familiarized themselves with design patterns. Having learned about patterns, they try to apply them everywhere, even in situations where simple code would do just fine.</li><li>Most design patterns lacks formal foundations.</li></ul> <h3>Classification of patterns</h3> <h3>Creational Patterns</h3> <p>Creational patterns are design patterns that deal with object creation mechanisms, trying to create objects in a manner suitable to the situation. The basic form of object creation could result in design problems or added complexity to the design. Creational design patterns solve this problem by somehow controlling this object creation.</p> <ul><li><strong>Singleton:</strong> A class of which only a single instance can exists.</li><li><strong>Abstract Factory:</strong> Create an instance of several families of classes</li><li><strong>Builder:</strong> Separates object construction from its representation.</li><li><strong>Factory Method:</strong> Creates an instance of several derived classes.</li><li><strong>Prototype:</strong> A fully initialized instance to be copied or cloned.</li></ul> <h3>Structural Patterns</h3> <p>These patterns explain how to assemble objects and classes into large structures while keeping these structures flexible and efficient.</p> <ul><li><strong>Adapter:</strong> Adapter is a structural design pattern that allows objects with incompatible interfaces to collaborate.</li><li><strong>Bridge:</strong> Bridge lets you split a large class or a set of closely related classes into two separate hierarchies: abstraction and implementation, which can be developed independently of each other.</li><li><strong>Composite:</strong> Composite lets you compose objects into tree structures and then work with these structures as if they were individual objects.</li><li><strong>Decorator:</strong> Decorator lets you attach new behaviors to objects by placing these objects inside special wrapper objects that contain the behaviors.</li><li><strong>Facade:</strong> Facade is a structural design that provides a simplified interface to a library, a framework, or any other complex set of classes.</li></ul> <h3>Behavioral Patterns</h3> <p>These patterns are concerned with algorithms and the assignment of responsibilities between objects.</p> <ul><li><strong>Chain of Responsibility:</strong> Chain of Responsibility is a behavioral design pattern that lets you pass requests along a chain of handlers.</li><li><strong>Iterator:</strong> Iterator let you traverse elements of a collection without exposing its underlying representation (list, stack, tree, etc.)</li><li><strong>Memento:</strong> Memento lets you save and restore the previous state of an object without revealing the detail of its implementation.</li></ul> <p><img src="https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=49267e419a5b" width="1" height="1" alt=""/></p>]]></content><author><name></name></author></entry></feed>