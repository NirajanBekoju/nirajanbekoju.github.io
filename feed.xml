<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator><link href="https://nirajanbekoju.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://nirajanbekoju.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2025-03-06T02:19:13+00:00</updated><id>https://nirajanbekoju.github.io/feed.xml</id><title type="html">blank</title><subtitle>A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. </subtitle><entry><title type="html">Improving Code Quality in Python with Pylint</title><link href="https://nirajanbekoju.github.io/blog/2025/improving-code-quality-in-python-with-pylint/" rel="alternate" type="text/html" title="Improving Code Quality in Python with Pylint"/><published>2025-03-06T01:44:49+00:00</published><updated>2025-03-06T01:44:49+00:00</updated><id>https://nirajanbekoju.github.io/blog/2025/improving-code-quality-in-python-with-pylint</id><content type="html" xml:base="https://nirajanbekoju.github.io/blog/2025/improving-code-quality-in-python-with-pylint/"><![CDATA[<p>Writing clean, efficient, and error-free code is crucial for any Python developer. One of the best tools for maintaining high code quality is <strong>Pylint</strong>â€Šâ€”â€Ša powerful static code analyzer for Python. Letâ€™s dive into how Pylint works, the types of errors it catches, and how we can improve our code usingÂ it.</p> <h3>What isÂ Pylint?</h3> <p>Pylint is a static code analysis tool for Python 2 and 3, with its latest version supporting Python 3.8.0 and above. It analyzes your code <strong>without running it</strong> and checksÂ for:</p> <ul><li><strong>Errors</strong> in theÂ code</li><li><strong>Coding standard violations</strong></li><li><strong>Code smells</strong> (areas that need refactoring)</li><li><strong>Suggestions</strong> for better code structure</li></ul> <p>Pylint also gives your code a <strong>score out of 10</strong> based on the number and severity of issuesÂ present.</p> <h3>Types of Errors inÂ Pylint</h3> <p>Pylint categorizes issues into five distinctÂ types:</p> <ul><li><strong>C: Convention</strong>â€Šâ€”â€ŠViolations of coding style and best practices</li><li><strong>R: Refactor</strong>â€Šâ€”â€ŠCode that could be simplified or restructured forÂ clarity</li><li><strong>W: Warning</strong>â€Šâ€”â€ŠPotential issues that might not stop execution but are problematic</li><li><strong>E: Error</strong>â€Šâ€”â€ŠClear programming mistakes</li><li><strong>F: Fatal</strong>â€Šâ€”â€ŠSerious errors that prevent Pylint fromÂ running</li></ul> <p>Letâ€™s see Pylint in action with some examples.</p> <h3>Example</h3> <pre># Write a Python program that takes two integers as input and performs division (num1 / num2). Handle the ZeroDivisionError and display a custom error message when the second number is zero.<br />import logging<br /><br />logging.basicConfig(<br />    filename=&quot;exception_handling.log&quot;, encoding=&quot;utf-8&quot;, level=logging.DEBUG<br />)<br /><br />try:<br />    num1 = int(input(&quot;Enter first number: &quot;))<br />    num2 = int(input(&quot;Enter second number: &quot;))<br />    result = num1 / num2<br />    print(result)<br />except ZeroDivisionError as e:<br />    logging.error(e)<br /><br /># Write a Python program that takes user input for age. Create a custom exception InvalidAgeError to handle cases where the age is below 0 or above 120.<br />class InvalidAgeError(Exception):<br />    pass<br /><br /><br />try:<br />    age = int(input(&quot;Enter your age: &quot;))<br />    if age &lt; 0 or age &gt; 120:<br />        raise InvalidAgeError(&quot;Age must be between 0 and 120&quot;)<br />    print(age)<br />except InvalidAgeError as e:<br />    logging.error(f&quot;{e}&quot;)Example 2: Custom Exception for Age Validation</pre> <h3>Pylint Analysis andÂ Results</h3> <p>When we examine above code using the pylint, we get different errors as given below. Our current score is 6.67.$ pylint 1_exception_handling.py</p> <p>We get several errors and warnings:</p> <pre>$ pylint 1_exception_handling.py <br />************* Module 1_exception_handling<br />1_exception_handling.py:1:0: C0301: Line too long (190/100) (line-too-long)<br />1_exception_handling.py:16:0: C0301: Line too long (152/100) (line-too-long)<br />1_exception_handling.py:1:0: C0114: Missing module docstring (missing-module-docstring)<br />1_exception_handling.py:1:0: C0103: Module name &quot;1_exception_handling&quot; doesn&#39;t conform to snake_case naming style (invalid-name)<br />1_exception_handling.py:17:0: C0115: Missing class docstring (missing-class-docstring)<br />1_exception_handling.py:27:4: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)<br /><br />------------------------------------------------------------------<br />Your code has been rated at 6.67/10 (previous run: 7.22/10, -0.56)Our initial Pylint score is 6.67/10.</pre> <h3>Fixing theÂ Errors</h3> <p>Letâ€™s fix these issues step byÂ step:</p> <ul><li><strong>line-too-long</strong>: Break long lines into multipleÂ lines</li><li><strong>missing-module-docstring</strong>: Add a docstring at the top of theÂ module</li><li><strong>invalid-name</strong>: Rename the module to follow snake_case convention</li><li><strong>missing-class-docstring</strong>: Add a docstring to the InvalidAgeError class</li><li><strong>logging-fstring-interpolation</strong>: Use %s formatting instead of f-strings inÂ logging</li></ul> <p>Hereâ€™s the <strong>refactored code</strong>:</p> <pre>&quot;&quot;&quot;<br />Exception Handling Assignments<br />&quot;&quot;&quot;<br /><br /># Write a Python program that takes two integers as input and performs division (num1 / num2).<br /># Handle the ZeroDivisionError and display a custom error message when the second number is zero.<br /><br />import logging<br /><br />logging.basicConfig(<br />    filename=&quot;exception_handling.log&quot;, encoding=&quot;utf-8&quot;, level=logging.DEBUG<br />)<br /><br />try:<br />    num1 = int(input(&quot;Enter first number: &quot;))<br />    num2 = int(input(&quot;Enter second number: &quot;))<br />    result = num1 / num2<br />    print(result)<br />except ZeroDivisionError as e:<br />    logging.error(&quot;%s&quot;, e)<br /><br /><br /># Write a Python program that takes user input for age.<br /># Create a custom exception InvalidAgeError to handle cases where the age is below 0 or above 120.<br />class InvalidAgeError(Exception):<br />    &quot;&quot;&quot;custom exception class for invalid age input&quot;&quot;&quot;<br /><br /><br />try:<br />    age = int(input(&quot;Enter your age: &quot;))<br />    if age &lt; 0 or age &gt; 120:<br />        raise InvalidAgeError(&quot;Age must be between 0 and 120&quot;)<br />    print(age)<br />except InvalidAgeError as e:<br />    logging.error(&quot;%s&quot;, e)import logging</pre> <h3>Final PylintÂ Score</h3> <p>Running PylintÂ again:</p> <pre>$ pylint exception_handling.py <br /><br />--------------------------------------------------------------------<br />Your code has been rated at 10.00/10 (previous run: 10.00/10, +0.00)</pre> <p>ğŸ‰ <strong>PerfectÂ score!</strong></p> <h3>Conclusion</h3> <p>Using Pylint regularly helps maintain clean, readable, and efficient Python code. It enforces best practices, catches errors early, and suggests improvementsâ€Šâ€”â€Šmaking you a better developer in the long run. Start integrating Pylint into your workflow and aim for that perfectÂ <strong>10/10</strong>!</p> <p><img src="https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=9f598d873e94" width="1" height="1" alt=""/></p>]]></content><author><name></name></author></entry><entry><title type="html">Design Pattern</title><link href="https://nirajanbekoju.github.io/blog/2025/design-pattern/" rel="alternate" type="text/html" title="Design Pattern"/><published>2025-03-06T01:31:49+00:00</published><updated>2025-03-06T01:31:49+00:00</updated><id>https://nirajanbekoju.github.io/blog/2025/design-pattern</id><content type="html" xml:base="https://nirajanbekoju.github.io/blog/2025/design-pattern/"><![CDATA[<p>Design pattern is a general repeatable solution to a commonly occurring problem in software design. A design pattern isnâ€™t a finished design that can be transformed directly into code. It is a description or template for how to solve a problem that can be used in many different situations.</p> <h3>Why learn design patterns?</h3> <ul><li>Design pattern are a toolkit of tried and tested solutions to common problems in softwareÂ design.</li><li>Design patterns define a common language that you and your teammates can use to communicate more efficiently.</li></ul> <h3>Criticism of designÂ patterns</h3> <ul><li>â€œIf all you have is a hammer, everything looks like a nailâ€. This is the the problem that haunts many beginners who have just familiarized themselves with design patterns. Having learned about patterns, they try to apply them everywhere, even in situations where simple code would do justÂ fine.</li><li>Most design patterns lacks formal foundations.</li></ul> <h3>Classification ofÂ patterns</h3> <h3>Creational Patterns</h3> <p>Creational patterns are design patterns that deal with object creation mechanisms, trying to create objects in a manner suitable to the situation. The basic form of object creation could result in design problems or added complexity to the design. Creational design patterns solve this problem by somehow controlling this object creation.</p> <ul><li><strong>Singleton:</strong> A class of which only a single instance canÂ exists.</li><li><strong>Abstract Factory:</strong> Create an instance of several families ofÂ classes</li><li><strong>Builder:</strong> Separates object construction from its representation.</li><li><strong>Factory Method:</strong> Creates an instance of several derivedÂ classes.</li><li><strong>Prototype:</strong> A fully initialized instance to be copied orÂ cloned.</li></ul> <h3>Structural Patterns</h3> <p>These patterns explain how to assemble objects and classes into large structures while keeping these structures flexible and efficient.</p> <ul><li><strong>Adapter:</strong> Adapter is a structural design pattern that allows objects with incompatible interfaces to collaborate.</li><li><strong>Bridge:</strong> Bridge lets you split a large class or a set of closely related classes into two separate hierarchies: abstraction and implementation, which can be developed independently of eachÂ other.</li><li><strong>Composite:</strong> Composite lets you compose objects into tree structures and then work with these structures as if they were individual objects.</li><li><strong>Decorator:</strong> Decorator lets you attach new behaviors to objects by placing these objects inside special wrapper objects that contain the behaviors.</li><li><strong>Facade:</strong> Facade is a structural design that provides a simplified interface to a library, a framework, or any other complex set ofÂ classes.</li></ul> <h3>Behavioral Patterns</h3> <p>These patterns are concerned with algorithms and the assignment of responsibilities betweenÂ objects.</p> <ul><li><strong>Chain of Responsibility:</strong> Chain of Responsibility is a behavioral design pattern that lets you pass requests along a chain of handlers.</li><li><strong>Iterator:</strong> Iterator let you traverse elements of a collection without exposing its underlying representation (list, stack, tree,Â etc.)</li><li><strong>Memento:</strong> Memento lets you save and restore the previous state of an object without revealing the detail of its implementation.</li></ul> <p><img src="https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=49267e419a5b" width="1" height="1" alt=""/></p>]]></content><author><name></name></author></entry></feed>