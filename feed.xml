<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator><link href="https://nirajanbekoju.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://nirajanbekoju.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2025-03-07T01:56:35+00:00</updated><id>https://nirajanbekoju.github.io/feed.xml</id><title type="html">blank</title><subtitle>A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. </subtitle><entry><title type="html">Mastering Logging in Python</title><link href="https://nirajanbekoju.github.io/blog/2025/mastering-logging-in-python/" rel="alternate" type="text/html" title="Mastering Logging in Python"/><published>2025-03-07T01:53:21+00:00</published><updated>2025-03-07T01:53:21+00:00</updated><id>https://nirajanbekoju.github.io/blog/2025/mastering-logging-in-python</id><content type="html" xml:base="https://nirajanbekoju.github.io/blog/2025/mastering-logging-in-python/"><![CDATA[<p>Logging in Python is a crucial aspect of software development, particularly for debugging, monitoring, and understanding the flow of your program. Python provides a built-in logging module that makes it easy to incorporate logging into your applications.</p> <h3>Why Logging¬†Matters</h3> <p>Logging is essential in software development for several¬†reasons:</p> <ol><li><strong>Debugging</strong>: Logs provide valuable information about what happened leading up to an error, helping developers diagnose and fix¬†issues.</li><li><strong>Monitoring</strong>: Logs help monitor the health and performance of an application, allowing developers and system administrators to identify trends, spot anomalies, and take proactive measures.</li><li><strong>Auditing</strong>: Logs serve as a record of events within a system, important for compliance, security audits, and forensic investigations.</li><li><strong>Performance Analysis</strong>: Logs contain performance data like response times and resource usage, which can help optimize an application‚Äôs performance.</li><li><strong>Troubleshooting</strong>: Logs track events across distributed systems, making it easier to diagnose and resolve¬†issues.</li></ol> <h3>Levels of¬†Logging</h3> <p>Python‚Äôs logging module supports different levels of logging, each serving a specific¬†purpose:</p> <ol><li><strong>DEBUG</strong>: Detailed information, used for debugging. Typically too verbose for production.</li><li><strong>INFO</strong>: General information about normal program operation.</li><li><strong>WARNING</strong>: Indicates a potential issue that doesn‚Äôt prevent program execution but might need attention.</li><li><strong>ERROR</strong>: Signals a serious problem that the program can recover from but may require intervention.</li><li><strong>CRITICAL</strong>: Indicates a critical error that may cause the program to crash or stop functioning.</li></ol> <h3>Practical Examples</h3> <h4>Basic Logger Configuration</h4> <p>Let‚Äôs start with a simple logger¬†setup:</p> <pre>&quot;&quot;&quot;<br />logging module<br />&quot;&quot;&quot;<br /><br />import logging<br /><br />logger = logging.getLogger(__name__)<br /><br />handler = logging.StreamHandler()<br /><br />FMT = &quot;%(levelname)s %(asctime)s [%(filename)s : %(funcName)s : %(lineno)d] %(message)s&quot;<br />formatter = logging.Formatter(FMT)<br />handler.setFormatter(formatter)<br /><br />logger.addHandler(handler)<br />logger.setLevel(logging.DEBUG)</pre> <p>Here, the stream handler sends logs to the console, and we define a custom format for log messages.</p> <p>We can now use this logger in another¬†module:</p> <pre>&quot;&quot;&quot;<br />division function module<br />&quot;&quot;&quot;<br /><br />from logger import logger<br /><br />try:<br />    num1 = int(input(&quot;Enter first number: &quot;))<br />    num2 = int(input(&quot;Enter second number: &quot;))<br />    result = num1 / num2<br />    print(result)<br />except ZeroDivisionError as e:<br />    logger.error(e)</pre> <p>When a division by zero occurs, the output looks like¬†this:</p> <pre>$ python3 division.py<br />Enter first number: 2<br />Enter second number: 0<br />ERROR 2024-04-16 10:13:48,341 [division.py : &lt;module&gt; : 13] division by zero</pre> <h4>Logger with File and Stream¬†Handlers</h4> <p>We can extend our logger to write logs to both the console and a¬†file:</p> <pre>&quot;&quot;&quot;<br />logger module with file and shell handler<br />&quot;&quot;&quot;<br /><br />import logging<br /><br />logger = logging.getLogger(__name__)<br /><br />shell_handler = logging.StreamHandler()<br />file_handler = logging.FileHandler(&quot;debug.log&quot;)<br /><br />logger.setLevel(logging.DEBUG)<br />shell_handler.setLevel(logging.WARNING)<br />file_handler.setLevel(logging.DEBUG)<br /><br />FMT_SHELL = &quot;%(levelname)s %(asctime)s %(message)s&quot;<br />FMT_FILE = (<br />    &quot;%(levelname)s %(asctime)s [%(filename)s:%(funcName)s:%(lineno)d] %(message)s&quot;<br />)<br /><br />shell_formatter = logging.Formatter(FMT_SHELL)<br />file_formatter = logging.Formatter(FMT_FILE)<br /><br />shell_handler.setFormatter(shell_formatter)<br />file_handler.setFormatter(file_formatter)<br /><br />logger.addHandler(shell_handler)<br />logger.addHandler(file_handler)logger = logging.getLogger(__name__)<br />shell_handler = logging.StreamHandler()<br />file_handler = logging.FileHandler(&quot;debug.log&quot;)</pre> <p>In this setup, the shell only shows warnings and above, while the file captures detailed debug information.</p> <h4>Rich Logger for Better Readability</h4> <p>Using the rich library, we can make our logs more readable:</p> <pre>&quot;&quot;&quot;<br />rich logger module<br />&quot;&quot;&quot;<br /><br />import logging<br /><br />from rich.logging import RichHandler<br /><br />logger = logging.getLogger(__name__)<br /><br /># the handler determines where the logs go: stdout/file<br />shell_handler = RichHandler()<br />file_handler = logging.FileHandler(&quot;debug.log&quot;)<br /><br />logger.setLevel(logging.DEBUG)<br />shell_handler.setLevel(logging.DEBUG)<br />file_handler.setLevel(logging.DEBUG)<br /><br /># the formatter determines what our logs will look like<br />FMT_SHELL = &quot;%(message)s&quot;<br />FMT_FILE = (<br />    &quot;%(levelname)s %(asctime)s [%(filename)s:%(funcName)s:%(lineno)d] %(message)s&quot;<br />)<br /><br />shell_formatter = logging.Formatter(FMT_SHELL)<br />file_formatter = logging.Formatter(FMT_FILE)<br /><br />shell_handler.setFormatter(shell_formatter)<br />file_handler.setFormatter(file_formatter)<br /><br />logger.addHandler(shell_handler)</pre> <p>The rich library enhances console output with better formatting and¬†color.</p> <h3>Conclusion</h3> <p>Python‚Äôs logging module is a powerful tool that helps developers track, debug, and monitor applications efficiently. Whether you‚Äôre using basic logging or integrating advanced features like the rich library, well-structured logs can save time and effort when diagnosing issues and analyzing performance.</p> <p>Happy logging!</p> <p><img src="https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=9c2b55db03e4" width="1" height="1" alt=""/></p>]]></content><author><name></name></author></entry><entry><title type="html">SOLID Design Pattern</title><link href="https://nirajanbekoju.github.io/blog/2025/solid-design-pattern/" rel="alternate" type="text/html" title="SOLID Design Pattern"/><published>2025-03-07T01:53:03+00:00</published><updated>2025-03-07T01:53:03+00:00</updated><id>https://nirajanbekoju.github.io/blog/2025/solid-design-pattern</id><content type="html" xml:base="https://nirajanbekoju.github.io/blog/2025/solid-design-pattern/"><![CDATA[<p>SOLID is groups of 5 principles that is used to build a better object-oriented code. These principles are:</p> <ol><li>Single Responsibility principle</li><li>Open-Closed principle</li><li>Liskov substitution principle</li><li>Interface segregation principle</li><li>Dependency inversion principle</li></ol> <h3>1. Single Responsibility Principle</h3> <p>It states that a class should have only one responsibility. If a class has more than one responsibilities, it should be divided into separate¬†class.</p> <p><strong>Example:</strong></p> <p>Say, we want to implement a simple program to interact with the library catalog system. For that, let‚Äôs create a python class Book to represent a single book with attributes: title, author, genre, availability(whether the book is available for borrowing or¬†not).</p> <pre>class Book:<br />    def __init__(self, title, author, isbn, genre, availability):<br />        self.title = title<br />        self.author = author<br />        self.isbn = isbn <br />        self.genre = genre <br />        self.availability = availability<br />    <br />    def get_detail(self):<br />        return (self.title, self.author, self.isbn, self.genre, self.availability)</pre> <p>Now, that we created a class for book, let‚Äôs create a LibraryCatalog class to manage the collection of books with following functionalities:</p> <ol><li>add books by storing each book¬†objects.</li><li>get book details and get all books from the list of¬†objects</li></ol> <pre>class LibraryCatalog:<br />    def __init__(self):<br />        self.books_list = []<br />    <br />    def add_book(self, book):<br />        self.books_list.append(book)<br />    <br />    def get_book_details(self, title):<br />        for book in self.books_list:<br />            if book.title == title:<br />                return book.get_detail()<br />        return &quot;Book not found in library catalog&quot;<br />    <br />    def get_all_books(self):<br />        if len(self.books_list) == 0:<br />            return &quot;No books available in the catalog&quot;<br />        return [book.get_detail() for book in self.books_list]</pre> <p>Now, we need a book borrowing process, let‚Äôs implement this resposibility with BookMangaer Class. Here, we have to check the availability of the book before borrowing them and make them available to borrow after returning them.</p> <pre>class BookManager:<br />    &quot;&quot;&quot;<br />    class for borrowing and returning book<br />    &quot;&quot;&quot;<br />    def __init__(self, library_catalog:LibraryCatalog):<br />        self.books_list = library_catalog.books_list<br />    <br />    def borrow_book(self, title):<br />        for book in self.books_list:<br />            if book.title == title:<br />                if book.availability:<br />                    book.availability = False <br />                    print(f&quot;{title} is borrowed.&quot;)<br />                else:<br />                    print(f&quot;{title} is not available&quot;)<br /><br />        print(&quot;f{title} is not found in library catalog&quot;)<br /><br />    def return_book(self, title):<br />        for book in self.books_list:<br />            if book.title == title:<br />                if not book.availability:<br />                    book.availability = True <br />                    print(f&quot;{title} is returned.&quot;)<br />                else:<br />                    print(f&quot;{title} is already available&quot;)<br /><br />        print(&quot;f{title} is not found in library catalog&quot;)</pre> <p>We have divided the responsibility of borrowing/returning, add/get book details and book details into different class. It follows the single responsibility principle.The overall implementation is as¬†follow:</p> <pre>class Book:<br />    def __init__(self, title, author, isbn, genre, availability):<br />        self.title = title<br />        self.author = author<br />        self.isbn = isbn <br />        self.genre = genre <br />        self.availability = availability<br />    <br />    def get_detail(self):<br />        return (self.title, self.author, self.isbn, self.genre, self.availability)<br /><br />class LibraryCatalog:<br />    def __init__(self):<br />        self.books_list = []<br />    <br />    def add_book(self, book):<br />        self.books_list.append(book)<br />    <br />    def get_book_details(self, title):<br />        for book in self.books_list:<br />            if book.title == title:<br />                return book.get_detail()<br />        return &quot;Book not found in library catalog&quot;<br />    <br />    def get_all_books(self):<br />        if len(self.books_list) == 0:<br />            return &quot;No books available in the catalog&quot;<br />        return [book.get_detail() for book in self.books_list]<br /><br />class BookManager:<br />    &quot;&quot;&quot;<br />    class for borrowing and returning book<br />    &quot;&quot;&quot;<br />    def __init__(self, library_catalog:LibraryCatalog):<br />        self.books_list = library_catalog.books_list<br />    <br />    def borrow_book(self, title):<br />        for book in self.books_list:<br />            if book.title == title:<br />                if book.availability:<br />                    book.availability = False <br />                    print(f&quot;{title} is borrowed.&quot;)<br />                else:<br />                    print(f&quot;{title} is not available&quot;)<br /><br />        print(&quot;f{title} is not found in library catalog&quot;)<br /><br />    def return_book(self, title):<br />        for book in self.books_list:<br />            if book.title == title:<br />                if not book.availability:<br />                    book.availability = True <br />                    print(f&quot;{title} is returned.&quot;)<br />                else:<br />                    print(f&quot;{title} is already available&quot;)<br /><br />        print(&quot;f{title} is not found in library catalog&quot;)<br /><br /><br />catalog = LibraryCatalog()<br />book_manager = BookManager(catalog)<br /><br />book1 = Book(&quot;Harry Potter and the Philosopher&#39;s Stone&quot;, &quot;J.K. Rowling&quot;, &quot;9780747532743&quot;, &quot;Fantasy&quot;, True)<br />book2 = Book(&quot;The Great Gatsby&quot;, &quot;F. Scott Fitzgerald&quot;, &quot;9780743273565&quot;, &quot;Classic&quot;, True)<br />catalog.add_book(book1)<br />catalog.add_book(book2)<br /><br />print()<br />print(&quot;get all books&quot;)<br />print(catalog.get_all_books())<br /><br />print()<br />print(&quot;get individual book detail&quot;)<br />book_title = &quot;The Great Gatsby&quot;<br />print(catalog.get_book_details(title=book_title))<br /><br />print()<br />print(&quot;BORROW BOOK&quot;)<br />book_manager.borrow_book(book_title)<br />print(catalog.get_book_details(title=book_title))<br /><br />print(&quot;\n&quot;)<br />print(&quot;RETURN BOOK&quot;)<br />book_manager.return_book(book_title)<br />print(catalog.get_book_details(title=book_title))</pre> <h3>2. Open Closed principle</h3> <p>Open closed principles states that software entities(classes, modules, functions, etc.) should be open for extension, but closed for modification.</p> <p>Here, Product class is implemented and total price is calculated based on the price of the¬†product.</p> <pre>class Product:<br />    def __init__(self, price):<br />        self.price = price<br /><br />def calculate_total_price(products):<br />    total_price = 0<br />    for product in products:<br />        total_price += product.price<br />    return total_price<br /><br /># Using the calculate_total_price function with a list of products<br />products = [Product(100), Product(50), Product(75)]<br />print(&quot;Total Price:&quot;, calculate_total_price(products))</pre> <p>Let‚Äôs say, we have to add a discount features, where some products might have a discount applied to their prices. To add this feature, we would need to modify the Product class and calculate_total_price function. This violates the open closed principle. So to incorporate the discount features, we can create a new class Discount that can provide the discount for the products as shown¬†below.</p> <pre>class Product:<br />    def __init__(self, price):<br />        self.price = price<br /><br /><br />def calculate_total_price(products):<br />    total_price = 0<br />    for product in products:<br />        total_price += product.price<br />    return total_price<br /><br /><br />class Discount:<br />    def __init__(self, product: Product, discount_percent: float):<br />        &quot;&quot;&quot;<br />        discount_percent(float) = [0,..., 1]<br />        &quot;&quot;&quot;<br />        self.product = product<br />        self.discount_percent = discount_percent<br /><br />    def give_discount(self):<br />        self.product.price = self.product.price * (1 - self.discount_percent)<br /><br /><br /># Using the calculate_total_price function with a list of products<br />products = [Product(200), Product(100), Product(50)]<br />print(&quot;Total Price before discount:&quot;, calculate_total_price(products))<br /><br /># apply discount<br />discount_percent = 0.2<br />for product in products:<br />    Discount(product, discount_percent).give_discount()<br /><br />print(&quot;Total Price after discount:&quot;, calculate_total_price(products))</pre> <h3>3. Liskov Substitution Principle(LSP)</h3> <p>It states that Sub types must be substitutable for their base types. It means objects should be replaceable by their subtypes without altering how the program¬†works.</p> <p><strong>Example:</strong> Below is an implementation of a banking system for account handling. There is a savings account and a checking account class. The cheking account inherits the savings account as both have the same functionality and the checking account allows overdrafts (allow processing transactions even if there is not sufficient balance). Now, we are going to redisgn the following program such that it follows the Liskov Substitution Principle.</p> <pre>class SavingsAccount():<br />    def __init__(self, balance) -&gt; None:<br />        self.balance = balance<br /><br />    def withdraw(self, amount):<br />        # Savings account does not allow overdrafts<br />        if amount &lt;= self.balance:<br />            self.balance -= amount<br />            print(f&quot;Withdrew ${amount}. Remaining balance: ${self.balance}&quot;)<br /><br />        else:<br />            print(&quot;Insufficient funds!&quot;)<br /><br />class CheckingAccount(SavingsAccount):<br />    def __init__(self, balance, overdraft_limit):<br />        super().__init__(balance)<br />        self.overdraft_limit = overdraft_limit<br /><br />    def withdraw(self, amount):<br />        # Checking account allows overdrafts but with a limit<br />        if amount &lt;= self.balance + self.overdraft_limit:<br />            self.balance -= amount<br />            print(f&quot;Withdrew ${amount}. Remaining balance: ${self.balance}&quot;)<br />        else:<br />            print(&quot;Exceeds overdraft limit or insufficient funds!&quot;)<br /><br />def perform_bank_actions(account):<br />    account.withdraw(100)<br />    account.withdraw(200)<br />    account.withdraw(500)<br /><br />if __name__ == &quot;__main__&quot;:<br />    # Creating instances of SavingsAccount and CheckingAccount<br />    savings_account = SavingsAccount(500)<br />    checking_account = CheckingAccount(1000, overdraft_limit=200)<br /><br />    # Performing actions on both accounts<br />    perform_bank_actions(savings_account)<br />    perform_bank_actions(checking_account)</pre> <p>In this example, we can‚Äôt substitute the instance of savings account to the checking account. Even though, a checking account is a specific type of a saving account, the classes that represent those account shouldn‚Äôt be in a parent-child relationship if LSP is followed.</p> <p>To follow LSP, we can create a base class for both savings account and checking account as¬†follow:</p> <pre>from abc import ABC, abstractmethod<br /><br />class Account(ABC):<br />    @abstractmethod<br />    def withdraw(self):<br />        pass<br /><br />class SavingsAccount(Account):<br />    def __init__(self, balance) -&gt; None:<br />        self.balance = balance<br /><br />    def withdraw(self, amount):<br />        # Savings account does not allow overdrafts<br />        if amount &lt;= self.balance:<br />            self.balance -= amount<br />            print(f&quot;Withdrew ${amount}. Remaining balance: ${self.balance}&quot;)<br /><br />        else:<br />            print(&quot;Insufficient funds!&quot;)<br /><br /><br />class CheckingAccount(Account):<br />    def __init__(self, balance, overdraft_limit):<br />        self.balance = balance<br />        self.overdraft_limit = overdraft_limit<br /><br />    def withdraw(self, amount):<br />        # Checking account allows overdrafts but with a limit<br />        if amount &lt;= self.balance + self.overdraft_limit:<br />            self.balance -= amount<br />            print(f&quot;Withdrew ${amount}. Remaining balance: ${self.balance}&quot;)<br />        else:<br />            print(&quot;Exceeds overdraft limit or insufficient funds!&quot;)<br /><br /><br />def perform_bank_actions(account):<br />    account.withdraw(100)<br />    account.withdraw(200)<br />    account.withdraw(500)<br /><br /><br />if __name__ == &quot;__main__&quot;:<br />    # Creating instances of SavingsAccount and CheckingAccount<br />    savings_account = SavingsAccount(500)<br />    checking_account = CheckingAccount(1000, overdraft_limit=200)<br /><br />    # Performing actions on both accounts<br />    perform_bank_actions(savings_account)<br />    perform_bank_actions(checking_account)</pre> <h3>4. Interface Segregation Principle(ISP)</h3> <p>The main idea regarding ISP is Clients should not be forced to depend upon methods that they donot use. Interfaces belongs to clients, not to hierarchies.</p> <p><strong>Example:</strong></p> <p>Suppose we have an interface called PaymentProcessor that defines methods for processing payments and refunds. Then, we have a class called OnlinePaymentProcessor that implements the PaymentProcessor interface. However, some parts of our system only need to process payments and don‚Äôt need to handle¬†refunds.</p> <pre>from abc import ABC, abstractmethod<br /><br />class PaymentProcessor(ABC):<br />    @abstractmethod<br />    def process_payment(self, amount):<br />        pass<br /><br />    @abstractmethod<br />    def process_refund(self, amount):<br />        pass<br /><br />class OnlinePaymentProcessor(PaymentProcessor):<br />    def process_payment(self, amount):<br />        print(f&quot;Processing payment of ${amount}&quot;)<br /><br />    def process_refund(self, amount):<br />        print(f&quot;Processing refund of ${amount}&quot;)</pre> <p>Now, we need to redesign this program such that it follows the ISP principle.</p> <pre>from abc import ABC, abstractmethod<br /><br /><br />class ProcessPayment(ABC):<br />    @abstractmethod<br />    def process_payment(self):<br />        pass<br /><br /><br />class ProcessFund(ABC):<br />    @abstractmethod<br />    def process_refund(self):<br />        pass<br /><br /><br />class ProcessPayOnly(ProcessPayment):<br />    def process_payment(self, amount):<br />        print(f&quot;Processing payment of ${amount}&quot;)<br /><br /><br />class ProcessFundOnly(ProcessFund):<br />    def process_refund(self, amount):<br />        print(f&quot;Processing refund of ${amount}&quot;)<br /><br /><br />class ProcessPayFundBoth(ProcessPayment, ProcessFund):<br />    def process_payment(self, amount):<br />        print(f&quot;Processing payment of ${amount}&quot;)<br /><br />    def process_refund(self, amount):<br />        print(f&quot;Processing refund of ${amount}&quot;)</pre> <p>Here, we created two separate class for payment and fund process and inherit them as required for different part of the system and so client is not forced to depend on methods they don‚Äôt use as per this implementation. Hence, ISP is followed.</p> <h3>5. Dependency Inversion Principle(DIP)</h3> <p>It states, ‚ÄúAbstractions should not depend upon details. Details should depend upon abstractions.‚Äù</p> <p><strong>Example:</strong> Suppose, we have a NotificationService class that is responsible for sending notifiction. The NotificationService class directly depends on the EmailSender Class to send emails. Hence, it violates the Dependency Inversion Principle. The high level NotificationService should not depend on the low-level EmailSender class, as it tightly couples the classes together.</p> <pre>class EmailSender:<br />    def send_email(self, recipient, subject, message):<br />        # Code to send an email<br />        print(f&quot;Sending email to {recipient}: {subject} - {message}&quot;)<br /><br />class NotificationService:<br />    def __init__(self):<br />        self.email_sender = EmailSender()<br /><br />    def send_notification(self, recipient, message):<br />        self.email_sender.send_email(recipient, &quot;Notification&quot;, message)<br /><br /># Using the NotificationService to send a notification<br />notification_service = NotificationService()<br />notification_service.send_notification(&quot;user@example.com&quot;, &quot;Hello, this is a notification!&quot;)</pre> <p>Suppose, we have to incorporate the SMSSender too in the above implementation. Then, due to tight dependency between the NotificationService and the EmailSender, it becomes a necessity to change the implemenation of NotificationService. So, it is not very scalable. Hence, we need to apply dependency inversion principle such that we can add different kinds of Notification Sender like EmailSender, SMSSender, etc. as done in the following implementation.</p> <pre>from abc import ABC, abstractmethod<br /><br /><br />class MessageSender(ABC):<br />    @abstractmethod<br />    def send_message(self, recipient, message):<br />        pass<br /><br /><br />class EmailSender(MessageSender):<br />    def send_message(self, recipient, message):<br />        print(f&quot;Sending email to {recipient}: {message}&quot;)<br /><br /><br />class SMSSender(MessageSender):<br />    def send_message(self, recipient, message):<br />        print(f&quot;Sending SMS to {recipient}: {message}&quot;)<br /><br /><br />class NotificationService:<br />    def __init__(self, sender: MessageSender) -&gt; None:<br />        self.sender = sender<br /><br />    def send_notification(self, recipient, message):<br />        self.sender.send_message(recipient, message)<br /><br /><br />email_sender = EmailSender()<br />notification_service = NotificationService(email_sender)<br />notification_service.send_notification(<br />    &quot;abcd@fusemachines.com&quot;, &quot;this is a notification&quot;<br />)<br /><br />sms_sender = SMSSender()<br />notification_service = NotificationService(sms_sender)<br />notification_service.send_notification(&quot;9843123122&quot;, &quot;this is a notification&quot;)class MessageSender(ABC):<br />    @abstractmethod<br />    def send_message(self, recipient, message):<br />        pass</pre> <h3>Conclusion</h3> <p>The SOLID principles are fundamental guidelines for writing clean, maintainable, and scalable object-oriented code. By following these principles‚Ää‚Äî‚ÄäSingle Responsibility, Open-Closed, Liskov Substitution, Interface Segregation, and Dependency Inversion‚Ää‚Äî‚Äädevelopers can avoid code smells, reduce tight coupling, and make their systems more adaptable to change. Understanding and applying SOLID principles ensures that your code remains robust and easy to extend as requirements evolve. Thank you for¬†reading!</p> <p><img src="https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=421921b3992b" width="1" height="1" alt=""/></p>]]></content><author><name></name></author></entry><entry><title type="html">Improving Code Quality in Python with Pylint</title><link href="https://nirajanbekoju.github.io/blog/2025/improving-code-quality-in-python-with-pylint/" rel="alternate" type="text/html" title="Improving Code Quality in Python with Pylint"/><published>2025-03-06T01:44:49+00:00</published><updated>2025-03-06T01:44:49+00:00</updated><id>https://nirajanbekoju.github.io/blog/2025/improving-code-quality-in-python-with-pylint</id><content type="html" xml:base="https://nirajanbekoju.github.io/blog/2025/improving-code-quality-in-python-with-pylint/"><![CDATA[<p>Writing clean, efficient, and error-free code is crucial for any Python developer. One of the best tools for maintaining high code quality is <strong>Pylint</strong>‚Ää‚Äî‚Ääa powerful static code analyzer for Python. Let‚Äôs dive into how Pylint works, the types of errors it catches, and how we can improve our code using¬†it.</p> <h3>What is¬†Pylint?</h3> <p>Pylint is a static code analysis tool for Python 2 and 3, with its latest version supporting Python 3.8.0 and above. It analyzes your code <strong>without running it</strong> and checks¬†for:</p> <ul><li><strong>Errors</strong> in the¬†code</li><li><strong>Coding standard violations</strong></li><li><strong>Code smells</strong> (areas that need refactoring)</li><li><strong>Suggestions</strong> for better code structure</li></ul> <p>Pylint also gives your code a <strong>score out of 10</strong> based on the number and severity of issues¬†present.</p> <h3>Types of Errors in¬†Pylint</h3> <p>Pylint categorizes issues into five distinct¬†types:</p> <ul><li><strong>C: Convention</strong>‚Ää‚Äî‚ÄäViolations of coding style and best practices</li><li><strong>R: Refactor</strong>‚Ää‚Äî‚ÄäCode that could be simplified or restructured for¬†clarity</li><li><strong>W: Warning</strong>‚Ää‚Äî‚ÄäPotential issues that might not stop execution but are problematic</li><li><strong>E: Error</strong>‚Ää‚Äî‚ÄäClear programming mistakes</li><li><strong>F: Fatal</strong>‚Ää‚Äî‚ÄäSerious errors that prevent Pylint from¬†running</li></ul> <p>Let‚Äôs see Pylint in action with some examples.</p> <h3>Example</h3> <pre># Write a Python program that takes two integers as input and performs division (num1 / num2). Handle the ZeroDivisionError and display a custom error message when the second number is zero.<br />import logging<br /><br />logging.basicConfig(<br />    filename=&quot;exception_handling.log&quot;, encoding=&quot;utf-8&quot;, level=logging.DEBUG<br />)<br /><br />try:<br />    num1 = int(input(&quot;Enter first number: &quot;))<br />    num2 = int(input(&quot;Enter second number: &quot;))<br />    result = num1 / num2<br />    print(result)<br />except ZeroDivisionError as e:<br />    logging.error(e)<br /><br /># Write a Python program that takes user input for age. Create a custom exception InvalidAgeError to handle cases where the age is below 0 or above 120.<br />class InvalidAgeError(Exception):<br />    pass<br /><br /><br />try:<br />    age = int(input(&quot;Enter your age: &quot;))<br />    if age &lt; 0 or age &gt; 120:<br />        raise InvalidAgeError(&quot;Age must be between 0 and 120&quot;)<br />    print(age)<br />except InvalidAgeError as e:<br />    logging.error(f&quot;{e}&quot;)Example 2: Custom Exception for Age Validation</pre> <h3>Pylint Analysis and¬†Results</h3> <p>When we examine above code using the pylint, we get different errors as given below. Our current score is 6.67.$ pylint 1_exception_handling.py</p> <p>We get several errors and warnings:</p> <pre>$ pylint 1_exception_handling.py <br />************* Module 1_exception_handling<br />1_exception_handling.py:1:0: C0301: Line too long (190/100) (line-too-long)<br />1_exception_handling.py:16:0: C0301: Line too long (152/100) (line-too-long)<br />1_exception_handling.py:1:0: C0114: Missing module docstring (missing-module-docstring)<br />1_exception_handling.py:1:0: C0103: Module name &quot;1_exception_handling&quot; doesn&#39;t conform to snake_case naming style (invalid-name)<br />1_exception_handling.py:17:0: C0115: Missing class docstring (missing-class-docstring)<br />1_exception_handling.py:27:4: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)<br /><br />------------------------------------------------------------------<br />Your code has been rated at 6.67/10 (previous run: 7.22/10, -0.56)Our initial Pylint score is 6.67/10.</pre> <h3>Fixing the¬†Errors</h3> <p>Let‚Äôs fix these issues step by¬†step:</p> <ul><li><strong>line-too-long</strong>: Break long lines into multiple¬†lines</li><li><strong>missing-module-docstring</strong>: Add a docstring at the top of the¬†module</li><li><strong>invalid-name</strong>: Rename the module to follow snake_case convention</li><li><strong>missing-class-docstring</strong>: Add a docstring to the InvalidAgeError class</li><li><strong>logging-fstring-interpolation</strong>: Use %s formatting instead of f-strings in¬†logging</li></ul> <p>Here‚Äôs the <strong>refactored code</strong>:</p> <pre>&quot;&quot;&quot;<br />Exception Handling Assignments<br />&quot;&quot;&quot;<br /><br /># Write a Python program that takes two integers as input and performs division (num1 / num2).<br /># Handle the ZeroDivisionError and display a custom error message when the second number is zero.<br /><br />import logging<br /><br />logging.basicConfig(<br />    filename=&quot;exception_handling.log&quot;, encoding=&quot;utf-8&quot;, level=logging.DEBUG<br />)<br /><br />try:<br />    num1 = int(input(&quot;Enter first number: &quot;))<br />    num2 = int(input(&quot;Enter second number: &quot;))<br />    result = num1 / num2<br />    print(result)<br />except ZeroDivisionError as e:<br />    logging.error(&quot;%s&quot;, e)<br /><br /><br /># Write a Python program that takes user input for age.<br /># Create a custom exception InvalidAgeError to handle cases where the age is below 0 or above 120.<br />class InvalidAgeError(Exception):<br />    &quot;&quot;&quot;custom exception class for invalid age input&quot;&quot;&quot;<br /><br /><br />try:<br />    age = int(input(&quot;Enter your age: &quot;))<br />    if age &lt; 0 or age &gt; 120:<br />        raise InvalidAgeError(&quot;Age must be between 0 and 120&quot;)<br />    print(age)<br />except InvalidAgeError as e:<br />    logging.error(&quot;%s&quot;, e)import logging</pre> <h3>Final Pylint¬†Score</h3> <p>Running Pylint¬†again:</p> <pre>$ pylint exception_handling.py <br /><br />--------------------------------------------------------------------<br />Your code has been rated at 10.00/10 (previous run: 10.00/10, +0.00)</pre> <p>üéâ <strong>Perfect¬†score!</strong></p> <h3>Conclusion</h3> <p>Using Pylint regularly helps maintain clean, readable, and efficient Python code. It enforces best practices, catches errors early, and suggests improvements‚Ää‚Äî‚Äämaking you a better developer in the long run. Start integrating Pylint into your workflow and aim for that perfect¬†<strong>10/10</strong>!</p> <p><img src="https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=9f598d873e94" width="1" height="1" alt=""/></p>]]></content><author><name></name></author></entry><entry><title type="html">Design Pattern</title><link href="https://nirajanbekoju.github.io/blog/2025/design-pattern/" rel="alternate" type="text/html" title="Design Pattern"/><published>2025-03-06T01:31:49+00:00</published><updated>2025-03-06T01:31:49+00:00</updated><id>https://nirajanbekoju.github.io/blog/2025/design-pattern</id><content type="html" xml:base="https://nirajanbekoju.github.io/blog/2025/design-pattern/"><![CDATA[<p>Design pattern is a general repeatable solution to a commonly occurring problem in software design. A design pattern isn‚Äôt a finished design that can be transformed directly into code. It is a description or template for how to solve a problem that can be used in many different situations.</p> <h3>Why learn design patterns?</h3> <ul><li>Design pattern are a toolkit of tried and tested solutions to common problems in software¬†design.</li><li>Design patterns define a common language that you and your teammates can use to communicate more efficiently.</li></ul> <h3>Criticism of design¬†patterns</h3> <ul><li>‚ÄúIf all you have is a hammer, everything looks like a nail‚Äù. This is the the problem that haunts many beginners who have just familiarized themselves with design patterns. Having learned about patterns, they try to apply them everywhere, even in situations where simple code would do just¬†fine.</li><li>Most design patterns lacks formal foundations.</li></ul> <h3>Classification of¬†patterns</h3> <h3>Creational Patterns</h3> <p>Creational patterns are design patterns that deal with object creation mechanisms, trying to create objects in a manner suitable to the situation. The basic form of object creation could result in design problems or added complexity to the design. Creational design patterns solve this problem by somehow controlling this object creation.</p> <ul><li><strong>Singleton:</strong> A class of which only a single instance can¬†exists.</li><li><strong>Abstract Factory:</strong> Create an instance of several families of¬†classes</li><li><strong>Builder:</strong> Separates object construction from its representation.</li><li><strong>Factory Method:</strong> Creates an instance of several derived¬†classes.</li><li><strong>Prototype:</strong> A fully initialized instance to be copied or¬†cloned.</li></ul> <h3>Structural Patterns</h3> <p>These patterns explain how to assemble objects and classes into large structures while keeping these structures flexible and efficient.</p> <ul><li><strong>Adapter:</strong> Adapter is a structural design pattern that allows objects with incompatible interfaces to collaborate.</li><li><strong>Bridge:</strong> Bridge lets you split a large class or a set of closely related classes into two separate hierarchies: abstraction and implementation, which can be developed independently of each¬†other.</li><li><strong>Composite:</strong> Composite lets you compose objects into tree structures and then work with these structures as if they were individual objects.</li><li><strong>Decorator:</strong> Decorator lets you attach new behaviors to objects by placing these objects inside special wrapper objects that contain the behaviors.</li><li><strong>Facade:</strong> Facade is a structural design that provides a simplified interface to a library, a framework, or any other complex set of¬†classes.</li></ul> <h3>Behavioral Patterns</h3> <p>These patterns are concerned with algorithms and the assignment of responsibilities between¬†objects.</p> <ul><li><strong>Chain of Responsibility:</strong> Chain of Responsibility is a behavioral design pattern that lets you pass requests along a chain of handlers.</li><li><strong>Iterator:</strong> Iterator let you traverse elements of a collection without exposing its underlying representation (list, stack, tree,¬†etc.)</li><li><strong>Memento:</strong> Memento lets you save and restore the previous state of an object without revealing the detail of its implementation.</li></ul> <p><img src="https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=49267e419a5b" width="1" height="1" alt=""/></p>]]></content><author><name></name></author></entry></feed>