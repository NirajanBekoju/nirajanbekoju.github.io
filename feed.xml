<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator><link href="https://nirajanbekoju.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://nirajanbekoju.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2025-03-08T18:39:33+00:00</updated><id>https://nirajanbekoju.github.io/feed.xml</id><title type="html">blank</title><subtitle>A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. </subtitle><entry><title type="html">Sequential Recommender System: Challenges, Progress and Prospects</title><link href="https://nirajanbekoju.github.io/blog/2025/sequential-recommender-system-challenges-progress-and-prospects/" rel="alternate" type="text/html" title="Sequential Recommender System: Challenges, Progress and Prospects"/><published>2025-03-08T06:26:55+00:00</published><updated>2025-03-08T06:26:55+00:00</updated><id>https://nirajanbekoju.github.io/blog/2025/sequential-recommender-system-challenges-progress-and-prospects</id><content type="html" xml:base="https://nirajanbekoju.github.io/blog/2025/sequential-recommender-system-challenges-progress-and-prospects/"><![CDATA[<h3>Introduction</h3> <figure><img alt="" src="https://cdn-images-1.medium.com/max/929/1*nSFke4MjQTKd18tEgAW9iQ.png"/></figure> <p><strong>Sequential Dependency</strong></p> <ul><li>The hotel may be close to the destination airport to the flight</li><li>Location for renting car may not be far away from the hotel.</li></ul> <p><strong>Sequential Recommendation System takes the prior sequential interactions as a context to predict which items would be interacted in the near future.</strong></p> <p><strong>Main Contribution of the paper:</strong></p> <ul><li>analyze the key challenges caused by different data characteristics in SRSs.</li><li>summarize the current research progress in SRSs by systematically categorizing the state-of-the-art works from a technical perspective.</li></ul> <h3>Data Characteristics and Challenges</h3> <ol><li><strong>Handling Long User-Item interaction sequences<br/></strong>a. Challenge 1: Learning higher-order sequential dependencies : Dependency on large number of previous transactions for purchase order<br/>b. Challenge 2: Learning long-term sequential dependencies : Dependency of current purchase on the previous items that are far from here.</li></ol> <figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*orAsT7ASU5Cwr9zQj2Xo8A.png"/></figure> <p>In the above sequence,</p> <ul><li>If we consider say n no. of previous purchase, it is n order sequential dependency.</li><li>the dependency of rose on vase after 3 interactions or purchases is the long-term sequential dependency.</li></ul> <p><strong>Existing Solutions:</strong></p> <ul><li>Higher-order Markov Chain</li><li>RNN</li></ul> <p><strong>2. Handling user-item interaction sequences with a flexible order</strong></p> <ul><li>In a shopping sequence = {milk, butter, flour},<br/>- the order of buying the milk and butter doesn’t matter<br/>- But the union of milk and butter leads to higher probability of buying the flour next.</li><li>In the condition where there flexibility in the order of purchase, it is better to capture the <strong>collective sequential dependencies</strong> rather than <strong>point-wise dependencies</strong></li></ul> <p><strong>Existing Solutions:</strong></p> <ul><li>CNN-based SRSs.</li></ul> <p><strong>3. Handling user-item interaction sequences with noise</strong></p> <ul><li>Some historical interactions are strongly relevant to the next interaction</li><li>While, others may be weakly or even irrelevant</li></ul> <p><strong>Existing Solutions:</strong></p> <ul><li>Attention models</li></ul> <p><strong>4. Handling user-item interaction sequences with heterogeneous relations</strong></p> <ul><li>Other than sequential dependencies, there can also be similarity based relations between the interacted items in terms of their features.</li><li>Hence another key challenges in building SRSs is how to effectively capture these heterogenouse relations embedded in the user-item interaction sequences respectively and to make them work collaboratively for the sequential recommendations.</li></ul> <p><strong>Existing Solutions:</strong></p> <ul><li>Mixture models are the only solution so far for this challenge</li><li>The mixture model integrates different types of relations modelled by different sub-models to collaboratively generate the sequential recommendations.</li></ul> <p>5. Handling user-item interaction sequences with hierarchical structures</p> <p>a. Hierarchical Relation 1: hierarchical structure between the metadata and user-item interactions. For ex: the user’s demographics can determine the users’ preferences in some degree.</p> <p>b. Hierarchical Relation 2: hierarchical structure between sub-sequences and user-item interactions.<br/> i. In some SRSs, one user-item interaction sequence includes multiple sub-sequences(also called sessions). These historical sequences can affect the current purchase.</p> <p><strong>Existing solutions:</strong></p> <ul><li>Hierarchical RNNs</li><li>Hierarchical attention</li></ul> <h3>Research Progress</h3> <figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*DPpfZ0rqJSI8hsk0UmRLVQ.png"/></figure> <p>Reference: <a href="https://arxiv.org/abs/2001.04830">https://arxiv.org/abs/2001.04830</a></p> <p><img src="https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=1a6c22551ea4" width="1" height="1" alt=""/></p>]]></content><author><name></name></author></entry><entry><title type="html">Singleton Design Pattern</title><link href="https://nirajanbekoju.github.io/blog/2025/singleton-design-pattern/" rel="alternate" type="text/html" title="Singleton Design Pattern"/><published>2025-03-08T06:26:39+00:00</published><updated>2025-03-08T06:26:39+00:00</updated><id>https://nirajanbekoju.github.io/blog/2025/singleton-design-pattern</id><content type="html" xml:base="https://nirajanbekoju.github.io/blog/2025/singleton-design-pattern/"><![CDATA[<p>Singleton is a creational design pattern that lets you ensure that a class has only one instance while providing a global access point to this instance.</p> <p>Singleton class ensures that a class has just a single instance. Here is how it works: imagine that you created an object, but after a while decided to create anew one. Instead of receiving a fresh object, you will get the one you already created.</p> <p>Why would anyone want to control how many instances a class has? The most common reason for this is to control access to some shared resource Example: a database or a file.</p> <p>Singleton class provides a global access point to that instance. The singleton pattern allows you to access some object from anywhere in the program. However, it also protects that instance from being overwritten by other code.</p> <p>Example:</p> <p>Implement a configuration manager using the singleton design pattern. The configuration manager should read configuration settings from a file and provide access to these settings throughout the application. Demonstrate how the single design pattern ensures that there is only one instance of the configuration manager, preventing unnecessary multiple reads of the configuration files.</p> <pre>import json<br /><br /><br />class ConfigurationManager(object):<br />    def __init__(self, config_file) -&gt; None:<br />        self.config_file = config_file<br />        self.configurations = self.load_config()<br /><br />    def __new__(self, config_file):<br />        &quot;&quot;&quot;<br />        create new instance if there are no other instance, else return the current instance<br />        &quot;&quot;&quot;<br />        if not hasattr(self, &quot;instance&quot;):<br />            self.instance = super(ConfigurationManager, self).__new__(self)<br />        return self.instance<br /><br />    def load_config(self):<br />        with open(self.config_file, &quot;r&quot;) as file:<br />            return json.load(file)<br /><br />    def get_config(self):<br />        return self.configurations<br /><br /><br />config_file = &quot;config.json&quot;<br />configuration_manager_1 = ConfigurationManager(config_file)<br />configuration_manager_2 = ConfigurationManager(config_file)<br />print(configuration_manager_1 is configuration_manager_2)<br /><br />config = configuration_manager_1.get_config()<br />print(type(config))<br />print(config)</pre> <p><img src="https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=27e26f065077" width="1" height="1" alt=""/></p>]]></content><author><name></name></author></entry><entry><title type="html">Learning to Rank: From Pairwise Approach to Listwise Approach</title><link href="https://nirajanbekoju.github.io/blog/2025/learning-to-rank-from-pairwise-approach-to-listwise-approach/" rel="alternate" type="text/html" title="Learning to Rank: From Pairwise Approach to Listwise Approach"/><published>2025-03-08T06:26:21+00:00</published><updated>2025-03-08T06:26:21+00:00</updated><id>https://nirajanbekoju.github.io/blog/2025/learning-to-rank-from-pairwise-approach-to-listwise-approach</id><content type="html" xml:base="https://nirajanbekoju.github.io/blog/2025/learning-to-rank-from-pairwise-approach-to-listwise-approach/"><![CDATA[<h3>Introduction</h3> <p>Learning to rank is concerned with a model or a function for ranking objects which is useful for various applications like document retrieval and collaborative filtering. The paper introduces two probability model: <strong>permutation probability and top one probability.</strong></p> <p>In document retrieval, there is a collection of documents. Given a query, the ranking function assigns a score to each document, and ranks the document in descending order of the scores. The ranking order represents the relative relevance of documents w.r.t. to the query.</p> <p>While training, a number of queries are provided; each query is associated with a perfect ranking list of documents; a ranking function is then created using the training data, such that the model can precisely predict the ranking lists in the training data.</p> <p>To calculate the listwise loss function, both the scores of documents assigned by a ranking function and the explicit or implicit judgments of the documents given by humans are transformed into the probability distribution. Then an metric between the probability distribution can be used as the loss function.</p> <p>The major contribution of the paper are:</p> <ul><li>proposal of the listwise approach</li><li>formulation of the listwise loss function on the basis of probability models</li><li>development of the ListNet method</li><li>empirical verification of the effectiveness of the approach</li></ul> <h3>Pairwise approach</h3> <p>In pairwise approach, the learning task is formalized as the classification of object pairs into two categories (correctly ranked and incorrectly ranked).</p> <h3>Permutation Probability</h3> <figure><img alt="" src="https://cdn-images-1.medium.com/max/770/1*PotEAldsDw_CvzZCU-0wlQ.jpeg"/></figure> <h3>Top One Probability</h3> <p>The top one probability of on object represents the probability of its being ranked on the top, given the scores of all the objects.</p> <figure><img alt="" src="https://cdn-images-1.medium.com/max/633/1*b3PeX4dasQndwS1JFyF40A.png"/></figure> <figure><img alt="" src="https://cdn-images-1.medium.com/max/633/1*5iEhkJ6eIEPF9YaYV7Yh_w.png"/></figure> <h3>Learning Method: ListNet</h3> <p>The paper developed a new learning method for optimizing the listwise loss function based on top one probability, with neural network as model and gradient descend as optimization algorithm called ListNet.</p> <h3>References</h3> <ul><li><a href="https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/tr-2007-40.pdf">https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/tr-2007-40.pdf</a></li><li><a href="https://embracingtherandom.com/machine-learning/tensorflow/ranking/deep-learning/learning-to-rank-part-1/">https://embracingtherandom.com/machine-learning/tensorflow/ranking/deep-learning/learning-to-rank-part-1/</a></li></ul> <p><img src="https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=eaa57769a74a" width="1" height="1" alt=""/></p>]]></content><author><name></name></author></entry><entry><title type="html">Factory Design Pattern</title><link href="https://nirajanbekoju.github.io/blog/2025/factory-design-pattern/" rel="alternate" type="text/html" title="Factory Design Pattern"/><published>2025-03-07T02:11:30+00:00</published><updated>2025-03-07T02:11:30+00:00</updated><id>https://nirajanbekoju.github.io/blog/2025/factory-design-pattern</id><content type="html" xml:base="https://nirajanbekoju.github.io/blog/2025/factory-design-pattern/"><![CDATA[<p>The factory method is based on a single function written to handle our object creation task. We execute it, passing a parameter that provides information about what we want, and, as a result, the wanted object is created. Interestingly, when using the factory method, we are not required to know any details about how the resulting object is implemented and where it is coming from.</p> <p><strong>Example:</strong></p> <p>Lets’s say, we want to build a logging system using the Factory Design Pattern. For that, create LoggerFactory class that generates different types of loggers(e.g, FileLogger, ConsoleLogger, DatabaseLogger). Implement methods in each logger to write logs to their respective destinations. Now, we are going to use Factory Design pattern to decouple the logging system from the application and allows for flexible log handling.</p> <pre>from abc import ABC, abstractmethod<br />import datetime<br />import sqlite3<br />import csv<br /><br />class Logger(ABC):<br />    @abstractmethod<br />    def log(self, message):<br />        pass<br /><br />class FileLogger(Logger):<br />    def __init__(self):<br />        super().__init__()<br />        print(&quot;creating the file logger object&quot;)<br />    def log(self, message):<br />        timestamp = str(datetime.datetime.now())<br />        with open(&quot;log_file.txt&quot;, &quot;a&quot;) as file:<br />            file.write(timestamp + &quot;\\t&quot; + message + &quot;\\n&quot;)<br /><br />class ConsoleLogger(Logger):<br />    def __init__(self):<br />        super().__init__()<br />        print(&quot;creating the console logger object&quot;)<br />    def log(self, message):<br />        timestamp = str(datetime.datetime.now())<br />        print(timestamp + &quot;\\t&quot; + message)<br />class CSVLogger(Logger):<br />    def __init__(self):<br />        super().__init__()<br />        print(&quot;creating the CSV logger object&quot;)<br />    def log(self, message):<br />        timestamp = str(datetime.datetime.now())<br />        log_entry = {&quot;timestamp&quot;: timestamp, &quot;message&quot;: message}<br />        with open(&quot;log.csv&quot;, &quot;a&quot;, newline=&quot;&quot;) as csvfile:<br />            fieldnames = [&quot;timestamp&quot;, &quot;message&quot;]<br />            writer = csv.DictWriter(csvfile, fieldnames=fieldnames)<br />            if csvfile.tell() == 0:<br />                writer.writeheader()<br />            writer.writerow(log_entry)<br /><br />class DatabaseLogger(Logger):<br />    def __init__(self) -&gt; None:<br />        super().__init__()<br />        self.connection = None<br />        self.cursor = None<br />        self.connect()<br />    def connect(self):<br />        self.connection = sqlite3.connect(&quot;log_database.db&quot;)<br />        self.cursor = self.connection.cursor()<br />        self.create_table()<br />    def create_table(self):<br />        self.cursor.execute(<br />            &quot;&quot;&quot;CREATE TABLE IF NOT EXISTS logs<br />                            (id INTEGER PRIMARY KEY,<br />                            message TEXT,<br />                            timestamp TIMESTAMP)&quot;&quot;&quot;<br />        )<br />        self.connection.commit()<br />    def log(self, message):<br />        timestamp = datetime.datetime.now()<br />        self.cursor.execute(<br />            &quot;INSERT INTO logs (message, timestamp) VALUES (?, ?)&quot;, (message, timestamp)<br />        )<br />        self.connection.commit()<br />    def close(self):<br />        self.connection.close()<br /><br />class LoggerFactory:<br />    def get_logger(self, logger_type):<br />        if logger_type == &quot;file&quot;:<br />            return FileLogger()<br />        elif logger_type == &quot;console&quot;:<br />            return ConsoleLogger()<br />        elif logger_type == &quot;csv&quot;:<br />            return CSVLogger()<br />        elif logger_type == &quot;database&quot;:<br />            return DatabaseLogger()<br />        else:<br />            raise ValueError(&quot;Invalid Logger type&quot;)<br /><br />if __name__ == &quot;__main__&quot;:<br />    logger_type_list = [&quot;file&quot;, &quot;console&quot;, &quot;csv&quot;, &quot;database&quot;]<br />    logger_type = logger_type_list[2]<br />    logger_factory = LoggerFactory()<br />    logger = logger_factory.get_logger(logger_type)<br />    logger.log(&quot;This is 4 log message.&quot;)</pre> <p>Hence, from above factory design pattern implementation, we can log our messages to any output file, console, csv or database, as we can create the object easily from the LoggerFactory.</p> <p><img src="https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=e9017649433e" width="1" height="1" alt=""/></p>]]></content><author><name></name></author></entry><entry><title type="html">Mastering Logging in Python</title><link href="https://nirajanbekoju.github.io/blog/2025/mastering-logging-in-python/" rel="alternate" type="text/html" title="Mastering Logging in Python"/><published>2025-03-07T01:53:21+00:00</published><updated>2025-03-07T01:53:21+00:00</updated><id>https://nirajanbekoju.github.io/blog/2025/mastering-logging-in-python</id><content type="html" xml:base="https://nirajanbekoju.github.io/blog/2025/mastering-logging-in-python/"><![CDATA[<p>Logging in Python is a crucial aspect of software development, particularly for debugging, monitoring, and understanding the flow of your program. Python provides a built-in logging module that makes it easy to incorporate logging into your applications.</p> <h3>Why Logging Matters</h3> <p>Logging is essential in software development for several reasons:</p> <ol><li><strong>Debugging</strong>: Logs provide valuable information about what happened leading up to an error, helping developers diagnose and fix issues.</li><li><strong>Monitoring</strong>: Logs help monitor the health and performance of an application, allowing developers and system administrators to identify trends, spot anomalies, and take proactive measures.</li><li><strong>Auditing</strong>: Logs serve as a record of events within a system, important for compliance, security audits, and forensic investigations.</li><li><strong>Performance Analysis</strong>: Logs contain performance data like response times and resource usage, which can help optimize an application’s performance.</li><li><strong>Troubleshooting</strong>: Logs track events across distributed systems, making it easier to diagnose and resolve issues.</li></ol> <h3>Levels of Logging</h3> <p>Python’s logging module supports different levels of logging, each serving a specific purpose:</p> <ol><li><strong>DEBUG</strong>: Detailed information, used for debugging. Typically too verbose for production.</li><li><strong>INFO</strong>: General information about normal program operation.</li><li><strong>WARNING</strong>: Indicates a potential issue that doesn’t prevent program execution but might need attention.</li><li><strong>ERROR</strong>: Signals a serious problem that the program can recover from but may require intervention.</li><li><strong>CRITICAL</strong>: Indicates a critical error that may cause the program to crash or stop functioning.</li></ol> <h3>Practical Examples</h3> <h4>Basic Logger Configuration</h4> <p>Let’s start with a simple logger setup:</p> <pre>&quot;&quot;&quot;<br />logging module<br />&quot;&quot;&quot;<br /><br />import logging<br /><br />logger = logging.getLogger(__name__)<br /><br />handler = logging.StreamHandler()<br /><br />FMT = &quot;%(levelname)s %(asctime)s [%(filename)s : %(funcName)s : %(lineno)d] %(message)s&quot;<br />formatter = logging.Formatter(FMT)<br />handler.setFormatter(formatter)<br /><br />logger.addHandler(handler)<br />logger.setLevel(logging.DEBUG)</pre> <p>Here, the stream handler sends logs to the console, and we define a custom format for log messages.</p> <p>We can now use this logger in another module:</p> <pre>&quot;&quot;&quot;<br />division function module<br />&quot;&quot;&quot;<br /><br />from logger import logger<br /><br />try:<br />    num1 = int(input(&quot;Enter first number: &quot;))<br />    num2 = int(input(&quot;Enter second number: &quot;))<br />    result = num1 / num2<br />    print(result)<br />except ZeroDivisionError as e:<br />    logger.error(e)</pre> <p>When a division by zero occurs, the output looks like this:</p> <pre>$ python3 division.py<br />Enter first number: 2<br />Enter second number: 0<br />ERROR 2024-04-16 10:13:48,341 [division.py : &lt;module&gt; : 13] division by zero</pre> <h4>Logger with File and Stream Handlers</h4> <p>We can extend our logger to write logs to both the console and a file:</p> <pre>&quot;&quot;&quot;<br />logger module with file and shell handler<br />&quot;&quot;&quot;<br /><br />import logging<br /><br />logger = logging.getLogger(__name__)<br /><br />shell_handler = logging.StreamHandler()<br />file_handler = logging.FileHandler(&quot;debug.log&quot;)<br /><br />logger.setLevel(logging.DEBUG)<br />shell_handler.setLevel(logging.WARNING)<br />file_handler.setLevel(logging.DEBUG)<br /><br />FMT_SHELL = &quot;%(levelname)s %(asctime)s %(message)s&quot;<br />FMT_FILE = (<br />    &quot;%(levelname)s %(asctime)s [%(filename)s:%(funcName)s:%(lineno)d] %(message)s&quot;<br />)<br /><br />shell_formatter = logging.Formatter(FMT_SHELL)<br />file_formatter = logging.Formatter(FMT_FILE)<br /><br />shell_handler.setFormatter(shell_formatter)<br />file_handler.setFormatter(file_formatter)<br /><br />logger.addHandler(shell_handler)<br />logger.addHandler(file_handler)logger = logging.getLogger(__name__)<br />shell_handler = logging.StreamHandler()<br />file_handler = logging.FileHandler(&quot;debug.log&quot;)</pre> <p>In this setup, the shell only shows warnings and above, while the file captures detailed debug information.</p> <h4>Rich Logger for Better Readability</h4> <p>Using the rich library, we can make our logs more readable:</p> <pre>&quot;&quot;&quot;<br />rich logger module<br />&quot;&quot;&quot;<br /><br />import logging<br /><br />from rich.logging import RichHandler<br /><br />logger = logging.getLogger(__name__)<br /><br /># the handler determines where the logs go: stdout/file<br />shell_handler = RichHandler()<br />file_handler = logging.FileHandler(&quot;debug.log&quot;)<br /><br />logger.setLevel(logging.DEBUG)<br />shell_handler.setLevel(logging.DEBUG)<br />file_handler.setLevel(logging.DEBUG)<br /><br /># the formatter determines what our logs will look like<br />FMT_SHELL = &quot;%(message)s&quot;<br />FMT_FILE = (<br />    &quot;%(levelname)s %(asctime)s [%(filename)s:%(funcName)s:%(lineno)d] %(message)s&quot;<br />)<br /><br />shell_formatter = logging.Formatter(FMT_SHELL)<br />file_formatter = logging.Formatter(FMT_FILE)<br /><br />shell_handler.setFormatter(shell_formatter)<br />file_handler.setFormatter(file_formatter)<br /><br />logger.addHandler(shell_handler)</pre> <p>The rich library enhances console output with better formatting and color.</p> <h3>Conclusion</h3> <p>Python’s logging module is a powerful tool that helps developers track, debug, and monitor applications efficiently. Whether you’re using basic logging or integrating advanced features like the rich library, well-structured logs can save time and effort when diagnosing issues and analyzing performance.</p> <p>Happy logging!</p> <p><img src="https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=9c2b55db03e4" width="1" height="1" alt=""/></p>]]></content><author><name></name></author></entry><entry><title type="html">SOLID Design Pattern</title><link href="https://nirajanbekoju.github.io/blog/2025/solid-design-pattern/" rel="alternate" type="text/html" title="SOLID Design Pattern"/><published>2025-03-07T01:53:03+00:00</published><updated>2025-03-07T01:53:03+00:00</updated><id>https://nirajanbekoju.github.io/blog/2025/solid-design-pattern</id><content type="html" xml:base="https://nirajanbekoju.github.io/blog/2025/solid-design-pattern/"><![CDATA[<p>SOLID is groups of 5 principles that is used to build a better object-oriented code. These principles are:</p> <ol><li>Single Responsibility principle</li><li>Open-Closed principle</li><li>Liskov substitution principle</li><li>Interface segregation principle</li><li>Dependency inversion principle</li></ol> <h3>1. Single Responsibility Principle</h3> <p>It states that a class should have only one responsibility. If a class has more than one responsibilities, it should be divided into separate class.</p> <p><strong>Example:</strong></p> <p>Say, we want to implement a simple program to interact with the library catalog system. For that, let’s create a python class Book to represent a single book with attributes: title, author, genre, availability(whether the book is available for borrowing or not).</p> <pre>class Book:<br />    def __init__(self, title, author, isbn, genre, availability):<br />        self.title = title<br />        self.author = author<br />        self.isbn = isbn <br />        self.genre = genre <br />        self.availability = availability<br />    <br />    def get_detail(self):<br />        return (self.title, self.author, self.isbn, self.genre, self.availability)</pre> <p>Now, that we created a class for book, let’s create a LibraryCatalog class to manage the collection of books with following functionalities:</p> <ol><li>add books by storing each book objects.</li><li>get book details and get all books from the list of objects</li></ol> <pre>class LibraryCatalog:<br />    def __init__(self):<br />        self.books_list = []<br />    <br />    def add_book(self, book):<br />        self.books_list.append(book)<br />    <br />    def get_book_details(self, title):<br />        for book in self.books_list:<br />            if book.title == title:<br />                return book.get_detail()<br />        return &quot;Book not found in library catalog&quot;<br />    <br />    def get_all_books(self):<br />        if len(self.books_list) == 0:<br />            return &quot;No books available in the catalog&quot;<br />        return [book.get_detail() for book in self.books_list]</pre> <p>Now, we need a book borrowing process, let’s implement this resposibility with BookMangaer Class. Here, we have to check the availability of the book before borrowing them and make them available to borrow after returning them.</p> <pre>class BookManager:<br />    &quot;&quot;&quot;<br />    class for borrowing and returning book<br />    &quot;&quot;&quot;<br />    def __init__(self, library_catalog:LibraryCatalog):<br />        self.books_list = library_catalog.books_list<br />    <br />    def borrow_book(self, title):<br />        for book in self.books_list:<br />            if book.title == title:<br />                if book.availability:<br />                    book.availability = False <br />                    print(f&quot;{title} is borrowed.&quot;)<br />                else:<br />                    print(f&quot;{title} is not available&quot;)<br /><br />        print(&quot;f{title} is not found in library catalog&quot;)<br /><br />    def return_book(self, title):<br />        for book in self.books_list:<br />            if book.title == title:<br />                if not book.availability:<br />                    book.availability = True <br />                    print(f&quot;{title} is returned.&quot;)<br />                else:<br />                    print(f&quot;{title} is already available&quot;)<br /><br />        print(&quot;f{title} is not found in library catalog&quot;)</pre> <p>We have divided the responsibility of borrowing/returning, add/get book details and book details into different class. It follows the single responsibility principle.The overall implementation is as follow:</p> <pre>class Book:<br />    def __init__(self, title, author, isbn, genre, availability):<br />        self.title = title<br />        self.author = author<br />        self.isbn = isbn <br />        self.genre = genre <br />        self.availability = availability<br />    <br />    def get_detail(self):<br />        return (self.title, self.author, self.isbn, self.genre, self.availability)<br /><br />class LibraryCatalog:<br />    def __init__(self):<br />        self.books_list = []<br />    <br />    def add_book(self, book):<br />        self.books_list.append(book)<br />    <br />    def get_book_details(self, title):<br />        for book in self.books_list:<br />            if book.title == title:<br />                return book.get_detail()<br />        return &quot;Book not found in library catalog&quot;<br />    <br />    def get_all_books(self):<br />        if len(self.books_list) == 0:<br />            return &quot;No books available in the catalog&quot;<br />        return [book.get_detail() for book in self.books_list]<br /><br />class BookManager:<br />    &quot;&quot;&quot;<br />    class for borrowing and returning book<br />    &quot;&quot;&quot;<br />    def __init__(self, library_catalog:LibraryCatalog):<br />        self.books_list = library_catalog.books_list<br />    <br />    def borrow_book(self, title):<br />        for book in self.books_list:<br />            if book.title == title:<br />                if book.availability:<br />                    book.availability = False <br />                    print(f&quot;{title} is borrowed.&quot;)<br />                else:<br />                    print(f&quot;{title} is not available&quot;)<br /><br />        print(&quot;f{title} is not found in library catalog&quot;)<br /><br />    def return_book(self, title):<br />        for book in self.books_list:<br />            if book.title == title:<br />                if not book.availability:<br />                    book.availability = True <br />                    print(f&quot;{title} is returned.&quot;)<br />                else:<br />                    print(f&quot;{title} is already available&quot;)<br /><br />        print(&quot;f{title} is not found in library catalog&quot;)<br /><br /><br />catalog = LibraryCatalog()<br />book_manager = BookManager(catalog)<br /><br />book1 = Book(&quot;Harry Potter and the Philosopher&#39;s Stone&quot;, &quot;J.K. Rowling&quot;, &quot;9780747532743&quot;, &quot;Fantasy&quot;, True)<br />book2 = Book(&quot;The Great Gatsby&quot;, &quot;F. Scott Fitzgerald&quot;, &quot;9780743273565&quot;, &quot;Classic&quot;, True)<br />catalog.add_book(book1)<br />catalog.add_book(book2)<br /><br />print()<br />print(&quot;get all books&quot;)<br />print(catalog.get_all_books())<br /><br />print()<br />print(&quot;get individual book detail&quot;)<br />book_title = &quot;The Great Gatsby&quot;<br />print(catalog.get_book_details(title=book_title))<br /><br />print()<br />print(&quot;BORROW BOOK&quot;)<br />book_manager.borrow_book(book_title)<br />print(catalog.get_book_details(title=book_title))<br /><br />print(&quot;\n&quot;)<br />print(&quot;RETURN BOOK&quot;)<br />book_manager.return_book(book_title)<br />print(catalog.get_book_details(title=book_title))</pre> <h3>2. Open Closed principle</h3> <p>Open closed principles states that software entities(classes, modules, functions, etc.) should be open for extension, but closed for modification.</p> <p>Here, Product class is implemented and total price is calculated based on the price of the product.</p> <pre>class Product:<br />    def __init__(self, price):<br />        self.price = price<br /><br />def calculate_total_price(products):<br />    total_price = 0<br />    for product in products:<br />        total_price += product.price<br />    return total_price<br /><br /># Using the calculate_total_price function with a list of products<br />products = [Product(100), Product(50), Product(75)]<br />print(&quot;Total Price:&quot;, calculate_total_price(products))</pre> <p>Let’s say, we have to add a discount features, where some products might have a discount applied to their prices. To add this feature, we would need to modify the Product class and calculate_total_price function. This violates the open closed principle. So to incorporate the discount features, we can create a new class Discount that can provide the discount for the products as shown below.</p> <pre>class Product:<br />    def __init__(self, price):<br />        self.price = price<br /><br /><br />def calculate_total_price(products):<br />    total_price = 0<br />    for product in products:<br />        total_price += product.price<br />    return total_price<br /><br /><br />class Discount:<br />    def __init__(self, product: Product, discount_percent: float):<br />        &quot;&quot;&quot;<br />        discount_percent(float) = [0,..., 1]<br />        &quot;&quot;&quot;<br />        self.product = product<br />        self.discount_percent = discount_percent<br /><br />    def give_discount(self):<br />        self.product.price = self.product.price * (1 - self.discount_percent)<br /><br /><br /># Using the calculate_total_price function with a list of products<br />products = [Product(200), Product(100), Product(50)]<br />print(&quot;Total Price before discount:&quot;, calculate_total_price(products))<br /><br /># apply discount<br />discount_percent = 0.2<br />for product in products:<br />    Discount(product, discount_percent).give_discount()<br /><br />print(&quot;Total Price after discount:&quot;, calculate_total_price(products))</pre> <h3>3. Liskov Substitution Principle(LSP)</h3> <p>It states that Sub types must be substitutable for their base types. It means objects should be replaceable by their subtypes without altering how the program works.</p> <p><strong>Example:</strong> Below is an implementation of a banking system for account handling. There is a savings account and a checking account class. The cheking account inherits the savings account as both have the same functionality and the checking account allows overdrafts (allow processing transactions even if there is not sufficient balance). Now, we are going to redisgn the following program such that it follows the Liskov Substitution Principle.</p> <pre>class SavingsAccount():<br />    def __init__(self, balance) -&gt; None:<br />        self.balance = balance<br /><br />    def withdraw(self, amount):<br />        # Savings account does not allow overdrafts<br />        if amount &lt;= self.balance:<br />            self.balance -= amount<br />            print(f&quot;Withdrew ${amount}. Remaining balance: ${self.balance}&quot;)<br /><br />        else:<br />            print(&quot;Insufficient funds!&quot;)<br /><br />class CheckingAccount(SavingsAccount):<br />    def __init__(self, balance, overdraft_limit):<br />        super().__init__(balance)<br />        self.overdraft_limit = overdraft_limit<br /><br />    def withdraw(self, amount):<br />        # Checking account allows overdrafts but with a limit<br />        if amount &lt;= self.balance + self.overdraft_limit:<br />            self.balance -= amount<br />            print(f&quot;Withdrew ${amount}. Remaining balance: ${self.balance}&quot;)<br />        else:<br />            print(&quot;Exceeds overdraft limit or insufficient funds!&quot;)<br /><br />def perform_bank_actions(account):<br />    account.withdraw(100)<br />    account.withdraw(200)<br />    account.withdraw(500)<br /><br />if __name__ == &quot;__main__&quot;:<br />    # Creating instances of SavingsAccount and CheckingAccount<br />    savings_account = SavingsAccount(500)<br />    checking_account = CheckingAccount(1000, overdraft_limit=200)<br /><br />    # Performing actions on both accounts<br />    perform_bank_actions(savings_account)<br />    perform_bank_actions(checking_account)</pre> <p>In this example, we can’t substitute the instance of savings account to the checking account. Even though, a checking account is a specific type of a saving account, the classes that represent those account shouldn’t be in a parent-child relationship if LSP is followed.</p> <p>To follow LSP, we can create a base class for both savings account and checking account as follow:</p> <pre>from abc import ABC, abstractmethod<br /><br />class Account(ABC):<br />    @abstractmethod<br />    def withdraw(self):<br />        pass<br /><br />class SavingsAccount(Account):<br />    def __init__(self, balance) -&gt; None:<br />        self.balance = balance<br /><br />    def withdraw(self, amount):<br />        # Savings account does not allow overdrafts<br />        if amount &lt;= self.balance:<br />            self.balance -= amount<br />            print(f&quot;Withdrew ${amount}. Remaining balance: ${self.balance}&quot;)<br /><br />        else:<br />            print(&quot;Insufficient funds!&quot;)<br /><br /><br />class CheckingAccount(Account):<br />    def __init__(self, balance, overdraft_limit):<br />        self.balance = balance<br />        self.overdraft_limit = overdraft_limit<br /><br />    def withdraw(self, amount):<br />        # Checking account allows overdrafts but with a limit<br />        if amount &lt;= self.balance + self.overdraft_limit:<br />            self.balance -= amount<br />            print(f&quot;Withdrew ${amount}. Remaining balance: ${self.balance}&quot;)<br />        else:<br />            print(&quot;Exceeds overdraft limit or insufficient funds!&quot;)<br /><br /><br />def perform_bank_actions(account):<br />    account.withdraw(100)<br />    account.withdraw(200)<br />    account.withdraw(500)<br /><br /><br />if __name__ == &quot;__main__&quot;:<br />    # Creating instances of SavingsAccount and CheckingAccount<br />    savings_account = SavingsAccount(500)<br />    checking_account = CheckingAccount(1000, overdraft_limit=200)<br /><br />    # Performing actions on both accounts<br />    perform_bank_actions(savings_account)<br />    perform_bank_actions(checking_account)</pre> <h3>4. Interface Segregation Principle(ISP)</h3> <p>The main idea regarding ISP is Clients should not be forced to depend upon methods that they donot use. Interfaces belongs to clients, not to hierarchies.</p> <p><strong>Example:</strong></p> <p>Suppose we have an interface called PaymentProcessor that defines methods for processing payments and refunds. Then, we have a class called OnlinePaymentProcessor that implements the PaymentProcessor interface. However, some parts of our system only need to process payments and don’t need to handle refunds.</p> <pre>from abc import ABC, abstractmethod<br /><br />class PaymentProcessor(ABC):<br />    @abstractmethod<br />    def process_payment(self, amount):<br />        pass<br /><br />    @abstractmethod<br />    def process_refund(self, amount):<br />        pass<br /><br />class OnlinePaymentProcessor(PaymentProcessor):<br />    def process_payment(self, amount):<br />        print(f&quot;Processing payment of ${amount}&quot;)<br /><br />    def process_refund(self, amount):<br />        print(f&quot;Processing refund of ${amount}&quot;)</pre> <p>Now, we need to redesign this program such that it follows the ISP principle.</p> <pre>from abc import ABC, abstractmethod<br /><br /><br />class ProcessPayment(ABC):<br />    @abstractmethod<br />    def process_payment(self):<br />        pass<br /><br /><br />class ProcessFund(ABC):<br />    @abstractmethod<br />    def process_refund(self):<br />        pass<br /><br /><br />class ProcessPayOnly(ProcessPayment):<br />    def process_payment(self, amount):<br />        print(f&quot;Processing payment of ${amount}&quot;)<br /><br /><br />class ProcessFundOnly(ProcessFund):<br />    def process_refund(self, amount):<br />        print(f&quot;Processing refund of ${amount}&quot;)<br /><br /><br />class ProcessPayFundBoth(ProcessPayment, ProcessFund):<br />    def process_payment(self, amount):<br />        print(f&quot;Processing payment of ${amount}&quot;)<br /><br />    def process_refund(self, amount):<br />        print(f&quot;Processing refund of ${amount}&quot;)</pre> <p>Here, we created two separate class for payment and fund process and inherit them as required for different part of the system and so client is not forced to depend on methods they don’t use as per this implementation. Hence, ISP is followed.</p> <h3>5. Dependency Inversion Principle(DIP)</h3> <p>It states, “Abstractions should not depend upon details. Details should depend upon abstractions.”</p> <p><strong>Example:</strong> Suppose, we have a NotificationService class that is responsible for sending notifiction. The NotificationService class directly depends on the EmailSender Class to send emails. Hence, it violates the Dependency Inversion Principle. The high level NotificationService should not depend on the low-level EmailSender class, as it tightly couples the classes together.</p> <pre>class EmailSender:<br />    def send_email(self, recipient, subject, message):<br />        # Code to send an email<br />        print(f&quot;Sending email to {recipient}: {subject} - {message}&quot;)<br /><br />class NotificationService:<br />    def __init__(self):<br />        self.email_sender = EmailSender()<br /><br />    def send_notification(self, recipient, message):<br />        self.email_sender.send_email(recipient, &quot;Notification&quot;, message)<br /><br /># Using the NotificationService to send a notification<br />notification_service = NotificationService()<br />notification_service.send_notification(&quot;user@example.com&quot;, &quot;Hello, this is a notification!&quot;)</pre> <p>Suppose, we have to incorporate the SMSSender too in the above implementation. Then, due to tight dependency between the NotificationService and the EmailSender, it becomes a necessity to change the implemenation of NotificationService. So, it is not very scalable. Hence, we need to apply dependency inversion principle such that we can add different kinds of Notification Sender like EmailSender, SMSSender, etc. as done in the following implementation.</p> <pre>from abc import ABC, abstractmethod<br /><br /><br />class MessageSender(ABC):<br />    @abstractmethod<br />    def send_message(self, recipient, message):<br />        pass<br /><br /><br />class EmailSender(MessageSender):<br />    def send_message(self, recipient, message):<br />        print(f&quot;Sending email to {recipient}: {message}&quot;)<br /><br /><br />class SMSSender(MessageSender):<br />    def send_message(self, recipient, message):<br />        print(f&quot;Sending SMS to {recipient}: {message}&quot;)<br /><br /><br />class NotificationService:<br />    def __init__(self, sender: MessageSender) -&gt; None:<br />        self.sender = sender<br /><br />    def send_notification(self, recipient, message):<br />        self.sender.send_message(recipient, message)<br /><br /><br />email_sender = EmailSender()<br />notification_service = NotificationService(email_sender)<br />notification_service.send_notification(<br />    &quot;abcd@fusemachines.com&quot;, &quot;this is a notification&quot;<br />)<br /><br />sms_sender = SMSSender()<br />notification_service = NotificationService(sms_sender)<br />notification_service.send_notification(&quot;9843123122&quot;, &quot;this is a notification&quot;)class MessageSender(ABC):<br />    @abstractmethod<br />    def send_message(self, recipient, message):<br />        pass</pre> <h3>Conclusion</h3> <p>The SOLID principles are fundamental guidelines for writing clean, maintainable, and scalable object-oriented code. By following these principles — Single Responsibility, Open-Closed, Liskov Substitution, Interface Segregation, and Dependency Inversion — developers can avoid code smells, reduce tight coupling, and make their systems more adaptable to change. Understanding and applying SOLID principles ensures that your code remains robust and easy to extend as requirements evolve. Thank you for reading!</p> <p><img src="https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=421921b3992b" width="1" height="1" alt=""/></p>]]></content><author><name></name></author></entry><entry><title type="html">Improving Code Quality in Python with Pylint</title><link href="https://nirajanbekoju.github.io/blog/2025/improving-code-quality-in-python-with-pylint/" rel="alternate" type="text/html" title="Improving Code Quality in Python with Pylint"/><published>2025-03-06T01:44:49+00:00</published><updated>2025-03-06T01:44:49+00:00</updated><id>https://nirajanbekoju.github.io/blog/2025/improving-code-quality-in-python-with-pylint</id><content type="html" xml:base="https://nirajanbekoju.github.io/blog/2025/improving-code-quality-in-python-with-pylint/"><![CDATA[<p>Writing clean, efficient, and error-free code is crucial for any Python developer. One of the best tools for maintaining high code quality is <strong>Pylint</strong> — a powerful static code analyzer for Python. Let’s dive into how Pylint works, the types of errors it catches, and how we can improve our code using it.</p> <h3>What is Pylint?</h3> <p>Pylint is a static code analysis tool for Python 2 and 3, with its latest version supporting Python 3.8.0 and above. It analyzes your code <strong>without running it</strong> and checks for:</p> <ul><li><strong>Errors</strong> in the code</li><li><strong>Coding standard violations</strong></li><li><strong>Code smells</strong> (areas that need refactoring)</li><li><strong>Suggestions</strong> for better code structure</li></ul> <p>Pylint also gives your code a <strong>score out of 10</strong> based on the number and severity of issues present.</p> <h3>Types of Errors in Pylint</h3> <p>Pylint categorizes issues into five distinct types:</p> <ul><li><strong>C: Convention</strong> — Violations of coding style and best practices</li><li><strong>R: Refactor</strong> — Code that could be simplified or restructured for clarity</li><li><strong>W: Warning</strong> — Potential issues that might not stop execution but are problematic</li><li><strong>E: Error</strong> — Clear programming mistakes</li><li><strong>F: Fatal</strong> — Serious errors that prevent Pylint from running</li></ul> <p>Let’s see Pylint in action with some examples.</p> <h3>Example</h3> <pre># Write a Python program that takes two integers as input and performs division (num1 / num2). Handle the ZeroDivisionError and display a custom error message when the second number is zero.<br />import logging<br /><br />logging.basicConfig(<br />    filename=&quot;exception_handling.log&quot;, encoding=&quot;utf-8&quot;, level=logging.DEBUG<br />)<br /><br />try:<br />    num1 = int(input(&quot;Enter first number: &quot;))<br />    num2 = int(input(&quot;Enter second number: &quot;))<br />    result = num1 / num2<br />    print(result)<br />except ZeroDivisionError as e:<br />    logging.error(e)<br /><br /># Write a Python program that takes user input for age. Create a custom exception InvalidAgeError to handle cases where the age is below 0 or above 120.<br />class InvalidAgeError(Exception):<br />    pass<br /><br /><br />try:<br />    age = int(input(&quot;Enter your age: &quot;))<br />    if age &lt; 0 or age &gt; 120:<br />        raise InvalidAgeError(&quot;Age must be between 0 and 120&quot;)<br />    print(age)<br />except InvalidAgeError as e:<br />    logging.error(f&quot;{e}&quot;)Example 2: Custom Exception for Age Validation</pre> <h3>Pylint Analysis and Results</h3> <p>When we examine above code using the pylint, we get different errors as given below. Our current score is 6.67.$ pylint 1_exception_handling.py</p> <p>We get several errors and warnings:</p> <pre>$ pylint 1_exception_handling.py <br />************* Module 1_exception_handling<br />1_exception_handling.py:1:0: C0301: Line too long (190/100) (line-too-long)<br />1_exception_handling.py:16:0: C0301: Line too long (152/100) (line-too-long)<br />1_exception_handling.py:1:0: C0114: Missing module docstring (missing-module-docstring)<br />1_exception_handling.py:1:0: C0103: Module name &quot;1_exception_handling&quot; doesn&#39;t conform to snake_case naming style (invalid-name)<br />1_exception_handling.py:17:0: C0115: Missing class docstring (missing-class-docstring)<br />1_exception_handling.py:27:4: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)<br /><br />------------------------------------------------------------------<br />Your code has been rated at 6.67/10 (previous run: 7.22/10, -0.56)Our initial Pylint score is 6.67/10.</pre> <h3>Fixing the Errors</h3> <p>Let’s fix these issues step by step:</p> <ul><li><strong>line-too-long</strong>: Break long lines into multiple lines</li><li><strong>missing-module-docstring</strong>: Add a docstring at the top of the module</li><li><strong>invalid-name</strong>: Rename the module to follow snake_case convention</li><li><strong>missing-class-docstring</strong>: Add a docstring to the InvalidAgeError class</li><li><strong>logging-fstring-interpolation</strong>: Use %s formatting instead of f-strings in logging</li></ul> <p>Here’s the <strong>refactored code</strong>:</p> <pre>&quot;&quot;&quot;<br />Exception Handling Assignments<br />&quot;&quot;&quot;<br /><br /># Write a Python program that takes two integers as input and performs division (num1 / num2).<br /># Handle the ZeroDivisionError and display a custom error message when the second number is zero.<br /><br />import logging<br /><br />logging.basicConfig(<br />    filename=&quot;exception_handling.log&quot;, encoding=&quot;utf-8&quot;, level=logging.DEBUG<br />)<br /><br />try:<br />    num1 = int(input(&quot;Enter first number: &quot;))<br />    num2 = int(input(&quot;Enter second number: &quot;))<br />    result = num1 / num2<br />    print(result)<br />except ZeroDivisionError as e:<br />    logging.error(&quot;%s&quot;, e)<br /><br /><br /># Write a Python program that takes user input for age.<br /># Create a custom exception InvalidAgeError to handle cases where the age is below 0 or above 120.<br />class InvalidAgeError(Exception):<br />    &quot;&quot;&quot;custom exception class for invalid age input&quot;&quot;&quot;<br /><br /><br />try:<br />    age = int(input(&quot;Enter your age: &quot;))<br />    if age &lt; 0 or age &gt; 120:<br />        raise InvalidAgeError(&quot;Age must be between 0 and 120&quot;)<br />    print(age)<br />except InvalidAgeError as e:<br />    logging.error(&quot;%s&quot;, e)import logging</pre> <h3>Final Pylint Score</h3> <p>Running Pylint again:</p> <pre>$ pylint exception_handling.py <br /><br />--------------------------------------------------------------------<br />Your code has been rated at 10.00/10 (previous run: 10.00/10, +0.00)</pre> <p>🎉 <strong>Perfect score!</strong></p> <h3>Conclusion</h3> <p>Using Pylint regularly helps maintain clean, readable, and efficient Python code. It enforces best practices, catches errors early, and suggests improvements — making you a better developer in the long run. Start integrating Pylint into your workflow and aim for that perfect <strong>10/10</strong>!</p> <p><img src="https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=9f598d873e94" width="1" height="1" alt=""/></p>]]></content><author><name></name></author></entry><entry><title type="html">Design Pattern</title><link href="https://nirajanbekoju.github.io/blog/2025/design-pattern/" rel="alternate" type="text/html" title="Design Pattern"/><published>2025-03-06T01:31:49+00:00</published><updated>2025-03-06T01:31:49+00:00</updated><id>https://nirajanbekoju.github.io/blog/2025/design-pattern</id><content type="html" xml:base="https://nirajanbekoju.github.io/blog/2025/design-pattern/"><![CDATA[<p>Design pattern is a general repeatable solution to a commonly occurring problem in software design. A design pattern isn’t a finished design that can be transformed directly into code. It is a description or template for how to solve a problem that can be used in many different situations.</p> <h3>Why learn design patterns?</h3> <ul><li>Design pattern are a toolkit of tried and tested solutions to common problems in software design.</li><li>Design patterns define a common language that you and your teammates can use to communicate more efficiently.</li></ul> <h3>Criticism of design patterns</h3> <ul><li>“If all you have is a hammer, everything looks like a nail”. This is the the problem that haunts many beginners who have just familiarized themselves with design patterns. Having learned about patterns, they try to apply them everywhere, even in situations where simple code would do just fine.</li><li>Most design patterns lacks formal foundations.</li></ul> <h3>Classification of patterns</h3> <h3>Creational Patterns</h3> <p>Creational patterns are design patterns that deal with object creation mechanisms, trying to create objects in a manner suitable to the situation. The basic form of object creation could result in design problems or added complexity to the design. Creational design patterns solve this problem by somehow controlling this object creation.</p> <ul><li><strong>Singleton:</strong> A class of which only a single instance can exists.</li><li><strong>Abstract Factory:</strong> Create an instance of several families of classes</li><li><strong>Builder:</strong> Separates object construction from its representation.</li><li><strong>Factory Method:</strong> Creates an instance of several derived classes.</li><li><strong>Prototype:</strong> A fully initialized instance to be copied or cloned.</li></ul> <h3>Structural Patterns</h3> <p>These patterns explain how to assemble objects and classes into large structures while keeping these structures flexible and efficient.</p> <ul><li><strong>Adapter:</strong> Adapter is a structural design pattern that allows objects with incompatible interfaces to collaborate.</li><li><strong>Bridge:</strong> Bridge lets you split a large class or a set of closely related classes into two separate hierarchies: abstraction and implementation, which can be developed independently of each other.</li><li><strong>Composite:</strong> Composite lets you compose objects into tree structures and then work with these structures as if they were individual objects.</li><li><strong>Decorator:</strong> Decorator lets you attach new behaviors to objects by placing these objects inside special wrapper objects that contain the behaviors.</li><li><strong>Facade:</strong> Facade is a structural design that provides a simplified interface to a library, a framework, or any other complex set of classes.</li></ul> <h3>Behavioral Patterns</h3> <p>These patterns are concerned with algorithms and the assignment of responsibilities between objects.</p> <ul><li><strong>Chain of Responsibility:</strong> Chain of Responsibility is a behavioral design pattern that lets you pass requests along a chain of handlers.</li><li><strong>Iterator:</strong> Iterator let you traverse elements of a collection without exposing its underlying representation (list, stack, tree, etc.)</li><li><strong>Memento:</strong> Memento lets you save and restore the previous state of an object without revealing the detail of its implementation.</li></ul> <p><img src="https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=49267e419a5b" width="1" height="1" alt=""/></p>]]></content><author><name></name></author></entry></feed>